<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 48: Problem 48: A* Search Algorithm — Graph Algorithms Mastery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.75;
            color: #1a202c;
            background-color: #f7fafc;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.08);
            padding: 48px 52px;
        }
        
        .content { max-width: 950px; margin: 0 auto; color: #1a202c; }
        .content h1 {
            color: #1a202c; margin: 32px 0 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #10b981;
            font-size: 2.1em;
            font-weight: 700;
        }
        .content h2 {
            color: #1a202c; margin: 28px 0 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #34d399;
            font-size: 1.6em;
            font-weight: 600;
        }
        .content h3 { color: #1a202c; margin: 22px 0 12px; font-size: 1.3em; font-weight: 600; }
        .content h4 { color: #2d3748; margin: 18px 0 10px; font-size: 1.1em; font-weight: 600; }
        .content p  { margin-bottom: 16px; line-height: 1.8; color: #1a202c; }
        .content ul, .content ol { margin: 12px 0 18px 30px; color: #1a202c; }
        .content li { margin-bottom: 8px; line-height: 1.75; color: #1a202c; }
        .content hr { border: none; border-top: 2px solid #e2e8f0; margin: 26px 0; }
        .content pre {
            background: #f7fafc !important;
            border: 1px solid #cbd5e0 !important;
            border-left: 4px solid #10b981 !important;
            padding: 18px !important; overflow-x: auto; margin: 18px 0; border-radius: 6px;
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.9em !important;
        }
        .content pre:not([style*="color"]) { color: #1a202c !important; }
        .content code {
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.88em !important;
        }
        .content code:not(pre code) {
            background: #d1fae5 !important;
            color: #1a202c !important;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .content pre code { background: transparent !important; padding: 0; }
        .content table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .content th {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white; padding: 12px 16px; text-align: left;
            font-weight: 600;
        }
        .content td { padding: 11px 16px; border: 1px solid #e2e8f0; color: #1a202c; }
        .content tr:nth-child(even) td { background: #ecfdf5; }
        .content blockquote {
            border-left: 4px solid #10b981; background: #ecfdf5;
            padding: 14px 20px; margin: 18px 0; border-radius: 0 6px 6px 0;
            color: #1a202c;
        }
        .content strong { color: #1a202c; font-weight: 600; }
        .px-2 { padding: 0; }
        .chat-message { background: transparent; padding: 0; margin: 0; }

        /* Bottom nav bar only */
        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 24px 0;
            margin-top: 50px;
            border-top: 3px solid #34d399;
        }
        .nav-button {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 12px 26px;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white !important; text-decoration: none;
            border-radius: 8px; font-weight: 600; font-size: 0.95em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16,185,129,0.35);
        }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 4px 14px rgba(16,185,129,0.5); }
        .nav-button.disabled { background: #cbd5e1; box-shadow: none; pointer-events: none; }
        .nav-button.home {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 2px 8px rgba(99,102,241,0.35);
        }
        .nav-button.home:hover { box-shadow: 0 4px 14px rgba(99,102,241,0.5); }
        .page-info { color: #718096; font-size: 0.9em; text-align: center; }

        /* Progress bar */
        #progress-track {
            position: fixed; top: 20px; right: 20px;
            width: 10px; height: 150px;
            background: rgba(16,185,129,0.2);
            border: 2px solid #10b981;
            border-radius: 6px; overflow: hidden; z-index: 1000;
        }
        #progress-fill {
            width: 100%;
            background: linear-gradient(180deg, #10b981, #059669);
            height: 0%;
            transition: height 0.15s ease;
        }
        #progress-pct {
            position: fixed; top: 0px; right: 16px;
            color: #059669; font-size: 14px; font-weight: bold;
            z-index: 1001;
            text-shadow: 0 1px 2px rgba(255,255,255,0.9);
            line-height: 20px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="chat-message" data-index="17">
<div class="px-2"><h1>Problem 48: A* Search Algorithm</h1>
<h2>[Algorithm Family: Informed / Heuristic Search]</h2>
<h2>[Phase 5: Expert — "I can design solutions for novel graph problems"]</h2>
<hr>
<h2>PROBLEM STATEMENT</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>You are building a GPS navigation system for a city grid.
</span>Given a 2D grid map where:
  - '.' represents open road
  - '#' represents a building (impassable)
  - 'S' represents the start position
  - 'G' represents the goal position

Find the SHORTEST PATH from S to G.

The grid is large (up to 1000 × 1000 = 1 million cells).
You know the COORDINATES of both S and G.

Can you do BETTER than exploring every reachable cell?

Input:
  grid = [
    ['.', '.', '.', '#', '.', '.', '.'],
    ['.', '#', '.', '#', '.', '#', '.'],
    ['.', '#', '.', '.', '.', '#', '.'],
    ['.', '.', '#', '#', '.', '.', '.'],
    ['#', '.', '.', '.', '#', '.', '.'],
    ['.', '.', '#', '.', '#', '.', 'G'],
    ['S', '.', '.', '.', '.', '#', '.'],
  ]

Output:
  Shortest path length from S to G
  And the actual path (list of coordinates)

Key constraint:
  → Grid can be very large
  → We KNOW the goal's location
  → Can we use this knowledge to search SMARTER?</code></pre></div>
<hr>
<h2>STEP 1: VISUALIZE FIRST — Draw the Grid</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Col:  0   1   2   3   4   5   6
</span>  
  R0:   .   .   .   #   .   .   .
  R1:   .   #   .   #   .   #   .
  R2:   .   #   .   .   .   #   .
  R3:   .   .   #   #   .   .   .
  R4:   #   .   .   .   #   .   .
  R5:   .   .   #   .   #   .   G     ← Goal at (5,6)
  R6:   S   .   .   .   .   #   .     ← Start at (6,0)
  
  Grid as a graph (implicit — Problem 6):
    → Each '.' or 'S' or 'G' cell = NODE
    → Adjacent cells (up/down/left/right) = EDGES
    → All edges have weight 1 (unweighted grid)
    → We KNOW start (6,0) and goal (5,6) COORDINATES</code></pre></div>
<h3>Identify Graph Properties</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>╔═══════════════════════════════════════════════════════════════════════╗
</span>║  Property        │  Answer               │  Why?                     ║
╠══════════════════╪═══════════════════════╪═══════════════════════════╣
║  NODES           │  Open grid cells      │  Each cell = node         ║
║  EDGES           │  4-directional adj    │  Up/down/left/right       ║
║  Directed?       │  NO                   │  Can move any direction   ║
║  Weighted?       │  YES (uniform = 1)    │  Each step costs 1        ║
║  Cyclic?         │  YES                  │  Can revisit areas        ║
║  Connected?      │  Maybe not fully      │  Walls may block          ║
║  Special         │  IMPLICIT graph       │  Grid defines structure   ║
║                  │  with KNOWN goal      │  Goal position is known!  ║
╚══════════════════╧═══════════════════════╧═══════════════════════════╝</code></pre></div>
<h3>Why Standard Algorithms Aren't Ideal Here</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  BFS (Problem 9):
    → Explores in ALL directions equally
    → Radiates outward like a circle from start
    → Explores cells AWAY from goal as eagerly as toward goal
    → On a 1000×1000 grid: might explore 500,000+ cells
    → CORRECT but WASTEFUL — doesn't use goal location!
  
  Dijkstra (Problem 23):
    → Same issue — no knowledge of goal direction
    → For uniform weights, degrades to BFS anyway
    → Explores everything within distance d before checking d+1
    
  BFS exploration pattern (from S toward G):
  
       . . . . . . .
       . . . . . . .
       . . X X X . .     X = explored by BFS
       . X X X X X .     but NOT on shortest path
       X X X X X X .     (wasted work!)
       X X X X X . G
       S X X X . . .
       
  We KNOW G is to the upper-right of S.
  Why explore cells to the LEFT and BELOW?
  
  A* IDEA: "Prefer exploring cells that are CLOSER to the goal"
  ═══════════════════════════════════════════════════════════════</code></pre></div>
<hr>
<h2>STEP 2: BRUTE FORCE FIRST</h2>
<h3>Approach: BFS (Explore Everything)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Standard BFS from S (Problem 9):
</span>    → Explore ALL reachable cells level by level
    → Stop when we first reach G
    → Correct, but explores many unnecessary cells
    
  Time: O(R × C) where R = rows, C = columns
  
  For 1000 × 1000 grid: explores up to 1,000,000 cells
  Even if goal is just 20 steps away in a straight line!</code></pre></div>
<h3>Why BFS Is Wasteful</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  BFS exploration radius from S = (6,0):
</span>  
  Distance 1: cells adjacent to S
  Distance 2: cells 2 steps from S
  Distance 3: cells 3 steps from S
  ...
  
  BFS explores a CIRCLE (in Manhattan distance) around S.
  But G is in a SPECIFIC DIRECTION.
  
  If shortest path has length d:
    BFS explores ≈ πd² cells (area of circle radius d)
    But only ≈ d cells are on the actual path!
    
  Wasted: O(d²) exploration for O(d) path length
  
  A* aims to explore ≈ O(d) cells by heading TOWARD the goal.
  (In practice, somewhere between O(d) and O(d²) depending on obstacles.)</code></pre></div>
<hr>
<h2>STEP 3: IDENTIFYING THE PATTERN</h2>
<h3>The A* Idea: Dijkstra + Heuristic</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  DIJKSTRA (Problem 23): 
    Priority = g(n) = actual distance from start to n
    "Process the node with smallest KNOWN distance"
    → Explores in concentric circles
    
  A*:
    Priority = f(n) = g(n) + h(n)
    
    g(n) = actual distance from START to n (same as Dijkstra)
    h(n) = ESTIMATED distance from n to GOAL (the heuristic)
    f(n) = estimated TOTAL distance of path through n
    
    "Process the node most likely on the SHORTEST TOTAL path"
    → Explores preferentially TOWARD the goal
  ═══════════════════════════════════════════════════════════════
  
  ANALOGY:
  
  Dijkstra: "I'll explore the nearest unexplored city"
    → Like exploring with a blindfold
    → Efficient in all directions, but doesn't aim
    
  A*: "I'll explore the city that seems closest to my destination"
    → Like exploring with a compass
    → Aims toward the goal while still finding shortest path
    
  ═══════════════════════════════════════════════════════════════
  THE HEURISTIC h(n)
  ═══════════════════════════════════════════════════════════════
  
  h(n) = our ESTIMATE of distance from n to goal
  
  For a grid with 4-directional movement:
    h(n) = Manhattan distance = |n.row - goal.row| + |n.col - goal.col|
    
  For a grid with 8-directional movement:
    h(n) = Chebyshev distance = max(|Δrow|, |Δcol|)
    
  For Euclidean space:
    h(n) = Euclidean distance = sqrt(Δrow² + Δcol²)
  
  CRITICAL REQUIREMENT: h(n) must be ADMISSIBLE
    → h(n) ≤ actual distance from n to goal
    → The heuristic must NEVER OVERESTIMATE
    → If it overestimates, A* might miss the true shortest path!
    
  WHY Manhattan distance is admissible for 4-directional grid:
    → You need AT LEAST |Δrow| + |Δcol| steps (even with no walls)
    → Walls can only make the path LONGER, never shorter
    → So Manhattan distance ≤ actual distance ✓</code></pre></div>
<h3>Visual: BFS vs Dijkstra vs A*</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  BFS explores (unweighted, all edges = 1):
  ═══════════════════════════════════════════════════════════════
  
       . . . . . . .         X = cells BFS explores
       . . . . . . .         before finding G
       . . X X X . .         
       . X X X X X .         Explores in ALL directions
       X X X X X X .         equally
       X X X X X . G
       S X X X X . .
       
  Total explored: ~25 cells
  
  ═══════════════════════════════════════════════════════════════
  A* explores (guided by Manhattan distance to G):
  ═══════════════════════════════════════════════════════════════
  
       . . . . . . .         X = cells A* explores
       . . . . . . .         before finding G
       . . . . X . .         
       . . . . X X .         Explores preferentially
       . . . X . X .         TOWARD goal
       . . . X . X G
       S X X X . . .
       
  Total explored: ~12 cells
  
  A* explored HALF as many cells as BFS!
  Both found the same shortest path.
  ═══════════════════════════════════════════════════════════════</code></pre></div>
<hr>
<h2>STEP 4: ALGORITHM WALKTHROUGH</h2>
<h3>Setup</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Grid:
</span>  Col:  0   1   2   3   4   5   6
  
  R0:   .   .   .   #   .   .   .
  R1:   .   #   .   #   .   #   .
  R2:   .   #   .   .   .   #   .
  R3:   .   .   #   #   .   .   .
  R4:   #   .   .   .   #   .   .
  R5:   .   .   #   .   #   .   G
  R6:   S   .   .   .   .   #   .
  
  Start S = (6, 0)
  Goal  G = (5, 6)
  
  Heuristic h(r,c) = |r - 5| + |c - 6|  (Manhattan distance to G)
  
  h(6,0) = |6-5| + |0-6| = 1 + 6 = 7
  h(5,6) = 0  (at goal)
  
  Data structures:
    open_set:  priority queue (min-heap) of (f, g, row, col)
    g_score:   dictionary {(r,c): best known g value}
    came_from: dictionary {(r,c): previous cell} for path reconstruction</code></pre></div>
<h3>Step-by-Step Trace</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  INITIAL STATE
  ═══════════════════════════════════════════════════════════════
  
  g(S) = 0
  h(S) = h(6,0) = 7
  f(S) = g + h = 0 + 7 = 7
  
  open_set = [(f=7, g=0, r=6, c=0)]
  g_score  = {(6,0): 0}</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ STEP 1: Pop (f=7, g=0, r=6, c=0) — Start cell              │
  │                                                              │
  │   Current: (6,0), g=0, f=7                                  │
  │   Is it goal? (6,0) ≠ (5,6) → NO                           │
  │                                                              │
  │   Neighbors of (6,0):                                        │
  │     Up:    (5,0) → '.' → valid                               │
  │     Down:  (7,0) → out of bounds → skip                     │
  │     Left:  (6,-1) → out of bounds → skip                    │
  │     Right: (6,1) → '.' → valid                               │
  │                                                              │
  │   Process (5,0):                                              │
  │     tentative_g = 0 + 1 = 1                                  │
  │     h(5,0) = |5-5| + |0-6| = 6                              │
  │     f = 1 + 6 = 7                                            │
  │     g_score[(5,0)] = 1                                        │
  │     Add (f=7, g=1, 5, 0) to open_set                        │
  │                                                              │
  │   Process (6,1):                                              │
  │     tentative_g = 0 + 1 = 1                                  │
  │     h(6,1) = |6-5| + |1-6| = 1+5 = 6                       │
  │     f = 1 + 6 = 7                                            │
  │     g_score[(6,1)] = 1                                        │
  │     Add (f=7, g=1, 6, 1) to open_set                        │
  │                                                              │
  │   open_set = [(7,1,5,0), (7,1,6,1)]                         │
  │   Both have f=7 — equally promising                          │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 2: Pop (f=7, g=1, r=5, c=0)                            │
  │                                                              │
  │   Current: (5,0), g=1, f=7                                  │
  │   Is goal? NO                                                │
  │                                                              │
  │   WHY did A* pick (5,0) over (6,1)?                          │
  │   Both have f=7. But (5,0) is CLOSER to goal (row-wise).    │
  │   Tie-breaking by coordinates or arbitrary.                  │
  │                                                              │
  │   Neighbors of (5,0):                                        │
  │     Up:    (4,0) → '#' → WALL → skip                        │
  │     Down:  (6,0) → g_score[(6,0)]=0 ≤ tentative_g=2 → skip │
  │     Left:  out of bounds → skip                              │
  │     Right: (5,1) → '.' → valid                               │
  │       tentative_g = 2, h(5,1) = 0+5 = 5, f = 7             │
  │       Add (7, 2, 5, 1)                                       │
  │                                                              │
  │   open_set = [(7,1,6,1), (7,2,5,1)]                         │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 3: Pop (f=7, g=1, r=6, c=1)                            │
  │                                                              │
  │   Current: (6,1), g=1                                        │
  │   Neighbors:                                                  │
  │     Up:    (5,1) → tentative_g=2, already g_score=2 → skip  │
  │     Down:  out of bounds                                     │
  │     Left:  (6,0) → already g_score=0 → skip                 │
  │     Right: (6,2) → '.' → valid                               │
  │       tentative_g = 2, h(6,2) = 1+4 = 5, f = 7             │
  │       Add (7, 2, 6, 2)                                       │
  │                                                              │
  │   open_set = [(7,2,5,1), (7,2,6,2)]                         │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Pattern Emerging</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Notice: ALL f-values so far are 7!
</span>  
  f = g + h = actual_distance + estimated_remaining
  
  If we're moving toward the goal efficiently:
    g increases by 1 each step
    h decreases by 1 each step (getting closer)
    f stays the same!
    
  This means A* is exploring cells on a "corridor" toward the goal.
  It's NOT exploring cells that go AWAY from the goal (those would 
  have f &gt; 7).
  
  Let me skip ahead to show the key decisions...</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ CONTINUING THE TRACE (summarized)...                          │
  │                                                              │
  │ A* follows a path heading right and up toward (5,6):         │
  │                                                              │
  │ Step 4: Process (6,2), g=2, f=7 → add (6,3) g=3 f=7        │
  │ Step 5: Process (5,1), g=2, f=7 → add... wall issues        │
  │ Step 6: Process (6,3), g=3, f=7 → add (6,4) g=4 f=8!       │
  │                                                              │
  │   Wait — f jumped to 8! Why?                                 │
  │   h(6,4) = |6-5| + |4-6| = 1 + 2 = 3                      │
  │   f = 4 + 3 = 7... actually still 7                         │
  │                                                              │
  │   Let me continue more carefully...                          │
  │                                                              │
  │ A* explores along the bottom row and through openings:       │
  │                                                              │
  │ The path found:                                               │
  │   (6,0)→(6,1)→(6,2)→(6,3)→(6,4)→(5,3)→(4,3)→(4,2)→       │
  │   (4,1)→(3,1)→(3,0)→(2,0)→... hmm, that's going backward  │
  │                                                              │
  │ Let me find the actual shortest path by inspection:           │
  │                                                              │
  │   R0:  .  .  .  #  .  .  .                                   │
  │   R1:  .  #  .  #  .  #  .                                   │
  │   R2:  .  #  .  .  .  #  .                                   │
  │   R3:  .  .  #  #  .  .  .                                   │
  │   R4:  #  .  .  .  #  .  .                                   │
  │   R5:  .  .  #  .  #  .  G                                   │
  │   R6:  S  .  .  .  .  #  .                                   │
  │                                                              │
  │ Path: S(6,0)→(6,1)→(6,2)→(6,3)→(6,4)→                      │
  │       (5,3)→(4,3)→(4,2)→(4,1)→(3,1)→(3,0)→                 │
  │       ... this is getting complicated with walls              │
  │                                                              │
  │ Simpler path through the middle:                              │
  │   (6,0)→(6,1)→(6,2)→(6,3)→(6,4)→(5,3)→(4,3)→              │
  │   (3,4)→(2,4)→(2,3)→(2,2)→... also complex                 │
  │                                                              │
  │ Let me find a cleaner path:                                   │
  │   (6,0)→(6,1)→(6,2)→(6,3)→(6,4)→                           │
  │   (5,3)→(4,3)→(4,2)→(4,1)→                                  │
  │   (3,1)→(3,0)→(2,0)→(1,0)→(0,0)→(0,1)→(0,2)→              │
  │   ... this goes WAY out of the way                           │
  │                                                              │
  │ Better: go right along bottom, then up, then right to goal:  │
  │   (6,0)→(6,1)→(6,2)→(6,3)→(6,4)→                           │
  │   (5,3)→(4,3)→(3,4)→(2,4)→(2,3)→(2,2)→                    │
  │   (1,2)→(0,2)→(0,1)→(0,0)→... no this is wrong direction   │
  │                                                              │
  │ Let me try right path:                                        │
  │   (6,0)→(6,1)→(6,2)→(6,3)→(6,4)→                           │
  │   (5,3)→(4,3)→(3,4)→(2,4)→(1,4)→(0,4)→                    │
  │   (0,5)→(0,6)→(1,6)→(2,6)... wait, (2,6) is '.'           │
  │   ... but (1,5) is '#' blocking direct path                  │
  │   (0,6)→(1,6)→... but need to check                         │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<p>Let me use a <strong>simpler grid</strong> for clearer walkthrough:</p>
<h3>Simplified Grid for Clean Trace</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Col:  0   1   2   3   4
</span>  
  R0:   S   .   #   .   .
  R1:   .   .   #   .   .
  R2:   .   .   .   .   #
  R3:   #   .   #   .   .
  R4:   .   .   .   .   G
  
  Start S = (0, 0)
  Goal  G = (4, 4)
  
  h(r,c) = |r-4| + |c-4| (Manhattan distance to G)
  
  h(0,0) = 4+4 = 8
  h(4,4) = 0</code></pre></div>
<h3>Complete Step-by-Step Trace on Simplified Grid</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  INITIAL
  ═══════════════════════════════════════════════════════════════
  
  open_set = [(f=8, g=0, 0, 0)]
  g_score  = {(0,0): 0}
  came_from = {}</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ STEP 1: Pop (f=8, g=0, r=0, c=0) — Start                   │
  │                                                              │
  │   (0,0) = S, not goal                                        │
  │                                                              │
  │   Neighbors:                                                  │
  │     (1,0): g=1, h=|1-4|+|0-4|=3+4=7, f=8                   │
  │     (0,1): g=1, h=|0-4|+|1-4|=4+3=7, f=8                   │
  │     (-1,0): out of bounds                                    │
  │     (0,-1): out of bounds                                    │
  │                                                              │
  │   open_set = [(8,1,0,1), (8,1,1,0)]                         │
  │   g_score = {(0,0):0, (0,1):1, (1,0):1}                     │
  │                                                              │
  │   Both have f=8 — both equally promising!                    │
  │   A* will pick one (let's say (0,1) — moving right toward G)│
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 2: Pop (f=8, g=1, r=0, c=1)                            │
  │                                                              │
  │   (0,1), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (0,0): g_score=0 ≤ tentative_g=2 → SKIP (already better)│
  │     (0,2): '#' → WALL → skip                                │
  │     (1,1): g=2, h=3+3=6, f=8 → ADD                          │
  │     (-1,1): out of bounds                                    │
  │                                                              │
  │   open_set = [(8,1,1,0), (8,2,1,1)]                         │
  │   g_score = {(0,0):0, (0,1):1, (1,0):1, (1,1):2}           │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 3: Pop (f=8, g=1, r=1, c=0)                            │
  │                                                              │
  │   (1,0), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (0,0): already g=0 → skip                                │
  │     (2,0): g=2, h=2+4=6, f=8 → ADD                          │
  │     (1,1): g_score=2 ≤ tentative=2 → SKIP (not better)     │
  │     (1,-1): out of bounds                                    │
  │                                                              │
  │   open_set = [(8,2,1,1), (8,2,2,0)]                         │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 4: Pop (f=8, g=2, r=1, c=1)                            │
  │                                                              │
  │   (1,1), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (0,1): g=1 ≤ 3 → skip                                   │
  │     (2,1): g=3, h=2+3=5, f=8 → ADD                          │
  │     (1,0): g=1 ≤ 3 → skip                                   │
  │     (1,2): '#' → wall                                        │
  │                                                              │
  │   open_set = [(8,2,2,0), (8,3,2,1)]                         │
  │                                                              │
  │   NOTE: f STILL = 8 for everything!                          │
  │   We're moving diagonally toward goal.                       │
  │   Each step: g+1, h-1, f stays same.                        │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 5: Pop (f=8, g=2, r=2, c=0)                            │
  │                                                              │
  │   (2,0), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (1,0): g=1 ≤ 3 → skip                                   │
  │     (3,0): '#' → wall                                        │
  │     (2,1): g_score=3 ≤ 3 → skip (not better)               │
  │     (2,-1): out of bounds                                    │
  │                                                              │
  │   Nothing new added! Dead end (wall below, already visited)  │
  │   A* naturally ABANDONS this direction.                      │
  │                                                              │
  │   open_set = [(8,3,2,1)]                                     │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 6: Pop (f=8, g=3, r=2, c=1)                            │
  │                                                              │
  │   (2,1), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (1,1): g=2 ≤ 4 → skip                                   │
  │     (3,1): g=4, h=1+3=4, f=8 → ADD                          │
  │     (2,0): g=2 ≤ 4 → skip                                   │
  │     (2,2): g=4, h=2+2=4, f=8 → ADD                          │
  │                                                              │
  │   open_set = [(8,4,2,2), (8,4,3,1)]                         │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 7: Pop (f=8, g=4, r=2, c=2)                            │
  │                                                              │
  │   (2,2), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (1,2): '#' → wall                                        │
  │     (3,2): '#' → wall                                        │
  │     (2,1): g=3 ≤ 5 → skip                                   │
  │     (2,3): g=5, h=2+1=3, f=8 → ADD                          │
  │                                                              │
  │   open_set = [(8,4,3,1), (8,5,2,3)]                         │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 8: Pop (f=8, g=4, r=3, c=1)                            │
  │                                                              │
  │   (3,1), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (2,1): g=3 ≤ 5 → skip                                   │
  │     (4,1): g=5, h=0+3=3, f=8 → ADD                          │
  │     (3,0): '#' → wall                                        │
  │     (3,2): '#' → wall                                        │
  │                                                              │
  │   open_set = [(8,5,2,3), (8,5,4,1)]                         │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 9: Pop (f=8, g=5, r=2, c=3)                            │
  │                                                              │
  │   (2,3), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (1,3): g=6, h=3+1=4, f=10! → ADD (higher f!)           │
  │     (3,3): g=6, h=1+1=2, f=8 → ADD                          │
  │     (2,2): g=4 ≤ 6 → skip                                   │
  │     (2,4): '#' → wall                                        │
  │                                                              │
  │   open_set = [(8,5,4,1), (8,6,3,3), (10,6,1,3)]            │
  │                                                              │
  │   NOTE: (1,3) has f=10 — it goes AWAY from goal!            │
  │   A* pushes it to the BACK of the queue.                    │
  │   It will only be explored if nothing with f≤10 reaches G.  │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 10: Pop (f=8, g=5, r=4, c=1)                           │
  │                                                              │
  │   (4,1), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (3,1): g=4 ≤ 6 → skip                                   │
  │     (4,0): g=6, h=0+4=4, f=10 → ADD                         │
  │     (4,2): g=6, h=0+2=2, f=8 → ADD                          │
  │                                                              │
  │   open_set = [(8,6,3,3), (8,6,4,2), (10,6,1,3), (10,6,4,0)]│
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 11: Pop (f=8, g=6, r=3, c=3)                           │
  │                                                              │
  │   (3,3), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (2,3): g=5 ≤ 7 → skip                                   │
  │     (4,3): g=7, h=0+1=1, f=8 → ADD                          │
  │     (3,2): '#' → wall                                        │
  │     (3,4): g=7, h=1+0=1, f=8 → ADD                          │
  │                                                              │
  │   open_set = [(8,6,4,2), (8,7,3,4), (8,7,4,3), ...]        │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 12: Pop (f=8, g=6, r=4, c=2)                           │
  │                                                              │
  │   (4,2), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (4,1): g=5 ≤ 7 → skip                                   │
  │     (4,3): tentative=7, g_score[(4,3)]=7 → skip (not better)│
  │     (3,2): '#' → wall                                        │
  │                                                              │
  │   Nothing useful added.                                      │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 13: Pop (f=8, g=7, r=3, c=4)                           │
  │                                                              │
  │   (3,4), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (2,4): '#' → wall                                        │
  │     (4,4): g=8, h=0+0=0, f=8 → ADD                          │
  │     (3,3): g=6 ≤ 8 → skip                                   │
  │                                                              │
  │   open_set = [(8,7,4,3), (8,8,4,4), ...]                    │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 14: Pop (f=8, g=7, r=4, c=3)                           │
  │                                                              │
  │   (4,3), not goal                                            │
  │                                                              │
  │   Neighbors:                                                  │
  │     (4,4): g_score=8 ≤ tentative=8 → skip (not better)     │
  │     (4,2): g=6 ≤ 8 → skip                                   │
  │     (3,3): g=6 ≤ 8 → skip                                   │
  │                                                              │
  │   Nothing new.                                               │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │ STEP 15: Pop (f=8, g=8, r=4, c=4)                           │
  │                                                              │
  │   (4,4) = G = GOAL FOUND!                                   │
  │                                                              │
  │   g = 8 → shortest path length = 8                           │
  │                                                              │
  │   DONE!                                                       │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Path Reconstruction</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Trace back via came_from:
</span>  
  (4,4) ← (3,4) ← (3,3) ← (2,3) ← (2,2) ← (2,1) ← (1,1) ← (0,1) ← (0,0)
  
  Path: (0,0)→(0,1)→(1,1)→(2,1)→(2,2)→(2,3)→(3,3)→(3,4)→(4,4)
  Length: 8 steps ✓
  
  Visualized on grid:
  
  Col:  0   1   2   3   4
  R0:  [S] [*]  #   .   .
  R1:   . [*]   #   .   .
  R2:   . [*] [*] [*]   #
  R3:   #   .   # [*] [*]
  R4:   .   .   .   . [G]
  
  [*] = cells on the shortest path
  
  Total cells explored by A*: ~15
  Total cells BFS would explore: ~20 (all reachable cells)
  
  A* saved: ~25% of exploration (more savings on larger grids!)</code></pre></div>
<h3>Comparison: What BFS Would Have Done</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  BFS explores in concentric rings from S:
</span>  
  Distance 0: (0,0)
  Distance 1: (0,1), (1,0)
  Distance 2: (1,1), (2,0)
  Distance 3: (2,1)
  Distance 4: (2,2), (3,1)
  Distance 5: (2,3), (4,1)
  Distance 6: (3,3), (4,0), (4,2)
  Distance 7: (3,4), (4,3)
  Distance 8: (4,4) ← FOUND!
  
  BFS explored cells going LEFT (4,0) and DOWN — useless directions!
  A* avoided those because their f-values were higher (f=10).</code></pre></div>
<hr>
<h2>STEP 5: COMPLETE CODE</h2>
<h3>Version 1: A* on Grid (Clean, Commented)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">import</span><span> heapq
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">astar_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    A* search on a 2D grid.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Finds shortest path from start to goal, exploring fewer cells 
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    than BFS by using a heuristic to guide search toward the goal.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Algorithm: Dijkstra (Problem 23) + heuristic function
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    f(n) = g(n) + h(n)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      g(n) = actual distance from start to n
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      h(n) = estimated distance from n to goal (Manhattan distance)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      f(n) = estimated total path cost through n
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Priority queue ordered by f(n):
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Nodes likely on the shortest path are explored first
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Nodes going away from goal have high h(n) → explored later
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Built on:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 6:  Grid as implicit graph
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 9:  BFS for shortest path (A* generalizes this)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 23: Dijkstra (A* = Dijkstra + heuristic)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Time:  O(V log V) worst case (same as Dijkstra)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">           But in practice, explores MUCH fewer nodes
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Space: O(V) for g_score, came_from, open_set
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    rows</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cols </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> start
</span><span>    gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Heuristic: Manhattan distance ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ADMISSIBLE: never overestimates (straight-line ≤ actual with walls)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># CONSISTENT: h(n) ≤ cost(n,m) + h(m) for all neighbors m</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gr</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>c </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Data structures ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># open_set: priority queue of (f_score, g_score, row, col)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># g_score: best known distance from start to each cell</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># came_from: for path reconstruction</span><span>
</span>    
<span>    g_score </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    g_score</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    f_start </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    open_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># (f, g, row, col)</span><span>
</span>    
<span>    came_from </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Directions: up, down, left, right</span><span>
</span><span>    directions </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    cells_explored </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># for comparison with BFS</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Main loop ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> open_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        f</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappop</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        cells_explored </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Goal check ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Reconstruct path</span><span>
</span><span>            path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> current </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>reverse</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cells_explored
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Skip if we've already found a better path to this cell ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># This can happen because we don't remove outdated entries</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># from the heap (lazy deletion)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> g_score</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>get</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Explore neighbors ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dc </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> directions</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> r </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dc
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Bounds check</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nr </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">or</span><span> nr </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> rows </span><span class="token" style="color: rgb(0, 0, 255);">or</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">or</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> cols</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Wall check</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nc</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Compute tentative g_score</span><span>
</span><span>            tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># each step costs 1</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Only process if this is a BETTER path to (nr, nc)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> g_score</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>get</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                g_score</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tentative_g
</span><span>                f_score </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappush</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_score</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> tentative_g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Goal not reachable</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cells_explored
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ═══════════════════════════════════════════════════════════════</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  TEST</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ═══════════════════════════════════════════════════════════════</span><span>
</span>
<span>grid </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'S'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'G'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span></span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>
<span>dist</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> explored </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> astar_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Shortest distance: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Path: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">path</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Cells explored by A*: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">explored</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<p><strong>Output:</strong></p>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>Shortest distance: 8
</span>Path: [(0,0), (0,1), (1,1), (2,1), (2,2), (2,3), (3,3), (3,4), (4,4)]
Cells explored by A*: 15</code></pre></div>
<hr>
<h3>Version 2: BFS for Comparison</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">bfs_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Standard BFS (Problem 9) for comparison with A*.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Same grid, same problem — but NO heuristic guidance.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    rows</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cols </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> start
</span><span>    gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span>    
<span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>sr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> sc</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># (row, col, distance)</span><span>
</span><span>    came_from </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    directions </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    cells_explored </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dist </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        cells_explored </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> current </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>reverse</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> dist</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cells_explored
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dc </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> directions</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> r </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dc
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nr </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> rows </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> cols</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> visited </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nc</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dist </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cells_explored
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── COMPARE ───</span><span>
</span><span>grid </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'S'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'G'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span></span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>
<span>dist_astar</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_astar</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> explored_astar </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> astar_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>dist_bfs</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_bfs</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> explored_bfs </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> bfs_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"A*:  distance=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist_astar</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, explored=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">explored_astar</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);"> cells"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"BFS: distance=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist_bfs</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, explored=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">explored_bfs</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);"> cells"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Both found same distance: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist_astar </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">==</span><span class="token string-interpolation interpolation"> dist_bfs</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"A* explored </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">explored_bfs </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">-</span><span class="token string-interpolation interpolation"> explored_astar</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);"> fewer cells"</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h3>Version 3: A* on General Weighted Graph (Not Just Grid)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">import</span><span> heapq
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">astar_general</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>adj</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> heuristic_fn</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    A* on a general weighted graph.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Args:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        adj: adjacency list {node: [(neighbor, weight), ...]}
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        start: start node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        goal: goal node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        heuristic_fn: function(node) → estimated distance to goal
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                      Must be ADMISSIBLE (never overestimate)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Returns:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        (distance, path) or (-1, []) if unreachable
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is the GENERAL A* — works on any graph, not just grids.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Grid A* (Version 1) is a special case where:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Nodes are (row, col) tuples
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Edges are 4-directional with weight 1
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Heuristic is Manhattan distance
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    g_score </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    f_start </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> heuristic_fn</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    open_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    came_from </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    closed_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> open_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        f</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappop</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> node </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Reconstruct path</span><span>
</span><span>            path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> current </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                current </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>current</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>reverse</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> closed_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span><span>        closed_set</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weight </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> closed_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>            
<span>            tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> weight
</span>            
<span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> g_score</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>get</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                g_score</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tentative_g
</span><span>                f_score </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tentative_g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> heuristic_fn</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappush</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_score</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> tentative_g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Test: City navigation ───</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Cities with coordinates (for heuristic) and road distances (for g)</span><span>
</span><span>city_coords </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>
</span><span>    </span><span class="token" style="color: rgb(163, 21, 21);">'A'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'B'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'C'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(163, 21, 21);">'D'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'E'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'F'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>
<span>adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>roads </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'A'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'B'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'A'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'C'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'B'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'D'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'C'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'D'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>         </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'C'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'E'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'D'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'F'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'E'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'F'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> roads</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Heuristic: Euclidean distance to goal F</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> math
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">h_to_F</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    x1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> y1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> city_coords</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    x2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> y2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> city_coords</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'F'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> math</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>sqrt</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>x1</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span>x2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">**</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>y1</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span>y2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">**</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>
<span>dist</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> astar_general</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>adj</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'A'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'F'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> h_to_F</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Shortest distance A to F: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Path: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">' → '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">join</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">path</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h2>STEP 6: COMPLEXITY ANALYSIS</h2>
<h3>Time Complexity</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │  WORST CASE: O(E log V)  (same as Dijkstra)                  │
  │                                                              │
  │  Why? In the worst case, A* explores ALL nodes               │
  │  (if heuristic is 0 for all nodes, A* = Dijkstra)           │
  │  Each node: push/pop from heap → O(log V)                   │
  │  Each edge: potentially causes a heap push → O(log V)       │
  │  Total: O((V + E) log V)                                    │
  ├──────────────────────────────────────────────────────────────┤
  │  BEST CASE: O(d log d) where d = shortest path length        │
  │                                                              │
  │  With a perfect heuristic (h = actual distance):             │
  │  A* explores ONLY nodes on the shortest path                 │
  │  d nodes explored, each with O(log d) heap operation        │
  ├──────────────────────────────────────────────────────────────┤
  │  TYPICAL CASE: Between best and worst                        │
  │                                                              │
  │  A good heuristic reduces explored nodes significantly.     │
  │  On grids: typically explores O(d × k) nodes                │
  │  where k depends on obstacle density                        │
  │  (k ≈ 1 for open grids, k ≈ d for maze-like grids)        │
  └──────────────────────────────────────────────────────────────┘
  
  ═══════════════════════════════════════════════════════════════
  THE REAL ADVANTAGE IS PRACTICAL, NOT ASYMPTOTIC
  ═══════════════════════════════════════════════════════════════
  
  A* and Dijkstra have the SAME worst-case complexity.
  But A* explores FEWER NODES in practice:
  
  ┌──────────────┬─────────────────┬──────────────────────────┐
  │  Scenario    │  BFS/Dijkstra   │  A*                      │
  ├──────────────┼─────────────────┼──────────────────────────┤
  │  Open grid   │  ~πd² nodes     │  ~d nodes                │
  │  100×100     │                 │  (huge savings!)         │
  ├──────────────┼─────────────────┼──────────────────────────┤
  │  Sparse maze │  ~πd²/2 nodes   │  ~d×√d nodes             │
  │              │                 │  (good savings)          │
  ├──────────────┼─────────────────┼──────────────────────────┤
  │  Dense maze  │  ~all reachable │  ~most reachable         │
  │  (labyrinth) │                 │  (minimal savings)       │
  └──────────────┴─────────────────┴──────────────────────────┘</code></pre></div>
<h3>Space Complexity: O(V)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │  Component                    │  Space                       │
  ├──────────────────────────────┼──────────────────────────────┤
  │  g_score dictionary           │  O(explored nodes)           │
  │  came_from dictionary         │  O(explored nodes)           │
  │  open_set (priority queue)    │  O(explored nodes)           │
  ├──────────────────────────────┼──────────────────────────────┤
  │  TOTAL                        │  O(V) worst case             │
  │                               │  O(explored) typical         │
  └──────────────────────────────┴──────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 7: HEURISTICS — THE HEART OF A*</h2>
<h3>What Makes a Good Heuristic?</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  REQUIREMENT 1: ADMISSIBILITY
  ═══════════════════════════════════════════════════════════════
  
  h(n) ≤ actual_distance(n, goal)   for ALL nodes n
  
  "Never overestimate the remaining distance"
  
  WHY? If h overestimates, A* might skip the true shortest path:
    → It thinks a node is far from goal (high f)
    → So it explores other nodes first
    → Those other nodes might lead to a LONGER path
    → A* returns that longer path, thinking it's shortest
    → WRONG ANSWER!
    
  If h underestimates (or equals): A* is GUARANTEED OPTIMAL.
  
  ═══════════════════════════════════════════════════════════════
  REQUIREMENT 2: CONSISTENCY (stronger, preferred)
  ═══════════════════════════════════════════════════════════════
  
  h(n) ≤ cost(n, m) + h(m)   for every edge (n, m)
  
  "The heuristic satisfies the triangle inequality"
  
  Consistency implies admissibility (but not vice versa).
  
  With consistency: once a node is popped from the heap,
  its g_score is FINAL (no need to revisit).
  This is like Dijkstra's guarantee.
  
  Without consistency: might need to revisit nodes.
  (This is rare in practice but important to know.)
  
  ═══════════════════════════════════════════════════════════════
  THE SPECTRUM OF HEURISTICS
  ═══════════════════════════════════════════════════════════════
  
  h(n) = 0 for all n:
    → A* degrades to Dijkstra
    → No guidance, explores everything within radius d
    → ALWAYS admissible, but useless
    
  h(n) = Manhattan distance (4-dir grid):
    → Tight lower bound
    → Very good guidance
    → ADMISSIBLE ✓ and CONSISTENT ✓
    
  h(n) = Euclidean distance:
    → Slightly looser than Manhattan for 4-dir grid
    → Still admissible (Euclidean ≤ Manhattan for 4-dir)
    → Good for continuous space / 8-dir grid
    
  h(n) = actual_distance(n, goal):
    → PERFECT heuristic
    → A* explores ONLY nodes on shortest path
    → But computing this IS the original problem!
    → (If we could compute it, we wouldn't need A*)
    
  h(n) = 2 × actual_distance(n, goal):
    → OVERESTIMATES → NOT admissible
    → A* becomes FASTER (more aggressive pruning)
    → But may return SUB-OPTIMAL paths
    → This is "Weighted A*" — trades optimality for speed</code></pre></div>
<h3>Heuristic Comparison Table</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────┬────────────┬────────────┬────────────┐
</span>  │  Heuristic             │  Admissible│  Speed     │  Optimality│
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = 0                 │  YES       │  Slow      │  Optimal   │
  │  (degrades to Dijkstra)│            │  (no guide)│            │
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = Euclidean dist    │  YES       │  Medium    │  Optimal   │
  │                        │            │            │            │
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = Manhattan dist    │  YES       │  Fast      │  Optimal   │
  │  (best for 4-dir grid) │  (4-dir)   │  (tight)   │            │
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = Diagonal dist     │  YES       │  Fast      │  Optimal   │
  │  (best for 8-dir grid) │  (8-dir)   │  (tight)   │            │
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = actual distance   │  YES       │  Fastest   │  Optimal   │
  │  (impossible to compute)│           │  (perfect) │            │
  ├────────────────────────┼────────────┼────────────┼────────────┤
  │  h = W × Manhattan     │  NO        │  Very fast │  Sub-opt   │
  │  W &gt; 1 (Weighted A*)   │  (W &gt; 1)   │  (aggress.)│  (W-approx)│
  └────────────────────────┴────────────┴────────────┴────────────┘
  
  RULE OF THUMB:
    "The tighter the heuristic (closer to actual distance),
     the fewer nodes A* explores."
    "But the heuristic must NEVER overestimate for optimality."</code></pre></div>
<hr>
<h2>STEP 8: PROOF OF OPTIMALITY — WHY A* WORKS</h2>
<code>  ═══════════════════════════════════════════════════════════════
  WHY A* WITH ADMISSIBLE HEURISTIC FINDS THE SHORTEST PATH
  ═══════════════════════════════════════════════════════════════
  
  CLAIM: When A* pops the goal node from the priority queue,
         the g-value IS the shortest distance from start to goal.
  
  PROOF INTUITION (by contradiction):
  
  Suppose A* pops goal with g = d, but the TRUE shortest path
  has length d* &lt; d.
  
  Consider any node X on the true shortest path that hasn't
  been popped yet (at least one such node exists — the goal
  on the true path wasn't popped with d*).
  
  For node X on the true shortest path:
    g(X) = actual distance from start to X on the true path
    h(X) ≤ actual distance from X to goal    (admissibility)
    
    f(X) = g(X) + h(X)
         ≤ g(X) + actual_distance(X, goal)
         = d*                                (total true path length)
         &lt; d                                 (our assumption)
         
  So f(X) &lt; d.
  
  But we popped goal with f(goal) = g(goal) + h(goal) = d + 0 = d.
  
  Since the priority queue pops MINIMUM f first,
  X should have been popped BEFORE goal (f(X) &lt; d = f(goal)).
  
  This means X WAS popped earlier. Processing X would have
  discovered the next node on the true path, eventually 
  reaching goal with g = d*.
  
  CONTRADICTION: We assumed goal was popped with g = d &gt; d*,
  but the true shortest path would have been discovered first.
  
  Therefore: d = d*. A* finds the optimal path. ∎
  
  ═══════════════════════════════════════════════════════════════
  INTUITIVE SUMMARY
  ═══════════════════════════════════════════════════════════════
  
  "Any node on a shorter path has a LOWER f-value than the 
   goal popped with a longer path. Since we pop minimum f first,
   the shorter path's nodes would be explored first, 
   reaching the goal with the correct shorter distance."
   
  KEY REQUIREMENT: h must NEVER overestimate
    → If h overestimates for node X: f(X) = g(X) + h(X) might 
      be LARGER than d, so X might NOT be popped before goal
    → The proof breaks down → A* might return wrong answer</code></pre></div>
<h3>Why Consistency Helps</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  ADMISSIBLE ONLY:
    → A* is optimal (finds shortest path)
    → BUT may pop the same node multiple times with different g-values
    → Need to allow re-expansion of nodes
    → Slightly more complex implementation
    
  CONSISTENT (h(n) ≤ cost(n,m) + h(m)):
    → A* is optimal AND
    → Once a node is popped, its g-value is FINAL
    → Never need to re-expand a node
    → Can use closed_set (like Dijkstra)
    → Simpler AND faster
    
  WHY consistency gives finality:
    If h is consistent, then along any path:
      f-values are NON-DECREASING
      
    Proof: f(m) = g(m) + h(m) 
                = g(n) + cost(n,m) + h(m)
                ≥ g(n) + h(n)        (by consistency: h(n) ≤ cost(n,m) + h(m))
                = f(n)
                
    So f never decreases along a path.
    First time we pop a node = minimum possible f = optimal g.
    
  GOOD NEWS: Manhattan distance on 4-dir grid IS consistent!
    h(n) = |nr-gr| + |nc-gc|
    For neighbor m one step away:
      h(n) ≤ 1 + h(m)  ← triangle inequality for Manhattan distance ✓
    So cost(n,m) + h(m) = 1 + h(m) ≥ h(n) ✓</code></pre></div>
<hr>
<h2>STEP 9: A* vs DIJKSTRA vs BFS — COMPLETE COMPARISON</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌─────────────┬──────────────────┬───────────────────┬──────────────────┐
</span>  │  Algorithm  │  Priority        │  Knows goal?      │  Exploration     │
  ├─────────────┼──────────────────┼───────────────────┼──────────────────┤
  │  BFS        │  FIFO (queue)    │  NO               │  Concentric      │
  │  (Problem 9)│  No priority     │                   │  circles         │
  │             │                  │                   │  (all directions)│
  ├─────────────┼──────────────────┼───────────────────┼──────────────────┤
  │  Dijkstra   │  g(n)            │  NO               │  Concentric      │
  │  (Prob 23)  │  (actual cost)   │  (stops at goal   │  ovals           │
  │             │                  │   but explores    │  (by weight)     │
  │             │                  │   all directions) │                  │
  ├─────────────┼──────────────────┼───────────────────┼──────────────────┤
  │  A*         │  f(n) = g(n) +   │  YES              │  Focused toward  │
  │  (THIS)     │  h(n)            │  (heuristic uses  │  goal            │
  │             │  (actual+estimate)│   goal location)  │  (guided search) │
  └─────────────┴──────────────────┴───────────────────┴──────────────────┘
  
  Visual comparison (start = left, goal = right):
  
  BFS/Dijkstra exploration:        A* exploration:
  
      X X X X X X                      . . . X X X
    X X X X X X X X                    . . X X X X X
  X X X X X X X X X X              . . [REDACTED:AWS_SECRET_KEY]
  [REDACTED:AWS_SECRET_KEY]              [REDACTED:AWS_SECRET_KEY] .
  X X X X X X X X X X              . . X X X X X X .
    X X X X X X X X                    . . X X X X .
      X X X X X X                      . . . X X .
      
  BFS: explored ~70 cells            A*: explored ~35 cells
  Both found same shortest path!     Half the work!
  
  ═══════════════════════════════════════════════════════════════
  WHEN TO USE WHICH
  ═══════════════════════════════════════════════════════════════
  
  BFS:
    → Unweighted graph
    → Don't know goal location (or want ALL shortest paths)
    → Simplest to implement
    
  Dijkstra:
    → Weighted graph with non-negative weights
    → Don't know goal location OR no useful heuristic
    → Want shortest path to ALL nodes (single source)
    
  A*:
    → Weighted graph with non-negative weights
    → KNOW goal location AND have good heuristic
    → Want shortest path to ONE specific goal
    → Want to minimize exploration (large graph)
    
  DAG DP (Problem 47):
    → Graph is a DAG (no cycles)
    → O(V+E) regardless — beats all of the above
    → Handles negative weights too</code></pre></div>
<hr>
<h2>STEP 10: WHEN A* DOESN'T HELP (AND WHAT TO DO)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  SCENARIO 1: No useful heuristic available
  ═══════════════════════════════════════════════════════════════
  
  If nodes don't have "positions" (abstract graph, not geometric):
    → Can't compute meaningful h(n)
    → Must use h(n) = 0 → A* degrades to Dijkstra
    → No benefit from A*
    
  Example: social network — "shortest path between two people"
    → People don't have coordinates
    → No way to estimate distance
    → Use BFS/Dijkstra instead
    
  ═══════════════════════════════════════════════════════════════
  SCENARIO 2: Dense maze / labyrinth
  ═══════════════════════════════════════════════════════════════
  
  If many walls force long detours:
    → Manhattan distance badly underestimates
    → Many nodes have similar f-values
    → A* explores almost everything anyway
    → Minimal savings over BFS
    
  Example:
    S # . . .        Path must go ALL the way around
    . # . # .        Manhattan says "goal is 4 steps right"
    . # . # .        Actual path: 20+ steps
    . # . # .        h is very loose → little guidance
    . . . # G
    
  ═══════════════════════════════════════════════════════════════
  SCENARIO 3: Need ALL shortest paths or shortest to ALL nodes
  ═══════════════════════════════════════════════════════════════
  
  A* optimizes for ONE specific goal.
  If you need shortest paths to ALL nodes:
    → Dijkstra is better (computes all at once)
    → Running A* for each target would be wasteful
    
  ═══════════════════════════════════════════════════════════════
  SCENARIO 4: Negative edge weights
  ═══════════════════════════════════════════════════════════════
  
  A* (like Dijkstra) requires non-negative edge weights.
  Negative weights → use Bellman-Ford (Problem 26) or DAG DP (Problem 47).
  
  ═══════════════════════════════════════════════════════════════
  SCENARIO 5: Graph is a DAG
  ═══════════════════════════════════════════════════════════════
  
  If graph is a DAG → DAG DP (Problem 47) is O(V+E)
  A* is O(V log V) at best → DAG DP always wins
  Don't use A* on DAGs!</code></pre></div>
<hr>
<h2>STEP 11: WEIGHTED A* AND VARIANTS</h2>
<h3>Weighted A* (ε-admissible)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">weighted_astar_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weight</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">1.5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Weighted A*: uses f(n) = g(n) + W × h(n) where W &gt; 1.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Trades OPTIMALITY for SPEED:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Explores fewer nodes (more aggressive toward goal)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Path length ≤ W × optimal path length (bounded sub-optimality)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    W = 1.0: standard A* (optimal)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    W = 1.5: path at most 50% longer, but MUCH faster
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    W = 2.0: path at most 2× longer, even faster
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    W = ∞:   pure greedy best-first search (no optimality guarantee)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Used in: game AI, real-time navigation, robotics
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Where "good enough fast" beats "optimal slow"
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> heapq
</span>    
<span>    rows</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cols </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gr</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>c </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    g_score </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    f_start </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> weight </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">*</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    open_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    came_from </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    closed </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    directions </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> open_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        f</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappop</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            cur </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> cur </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>cur</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                cur </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>cur</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>reverse</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> closed</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span><span>        closed</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dc </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> directions</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> r </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dc
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nr </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> rows </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> cols </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nc</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> closed</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    tent_g </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> tent_g </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> g_score</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>get</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        g_score</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tent_g
</span><span>                        f_new </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> tent_g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> weight </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> heuristic</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        heapq</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>heappush</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>open_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>f_new</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> tent_g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        came_from</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span></code></pre></div>
<h3>Bidirectional A* (Combined with Problem 42)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  BIDIRECTIONAL A* = A* from BOTH ends simultaneously
  ═══════════════════════════════════════════════════════════════
  
  Run two A* searches:
    Forward:  from start toward goal (h = distance to goal)
    Backward: from goal toward start (h = distance to start)
    
  Stop when the two searches MEET in the middle.
  
  Exploration reduction:
    Regular A*:       explores ≈ O(b^d) nodes (b = branching, d = depth)
    Bidirectional A*: explores ≈ O(b^(d/2)) nodes
    
  This combines Problem 42 (Bidirectional BFS) with A*.
  
  TRICKY: termination condition is complex
    → Can't just stop when frontiers meet
    → Must ensure no shorter path exists through unexplored nodes
    → Need careful bookkeeping</code></pre></div>
<h3>IDA* (Iterative Deepening A*)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  IDA* = A* with O(1) memory
  ═══════════════════════════════════════════════════════════════
  
  Problem with A*: stores ALL explored nodes in memory → O(V) space
  For very large graphs (millions of nodes): memory runs out
  
  IDA* solution:
    → Use iterative deepening (like iterative deepening DFS)
    → Set a threshold f_limit
    → DFS, pruning any node with f(n) &gt; f_limit
    → If goal not found: increase f_limit to min f of pruned nodes
    → Repeat
    
  Space: O(d) — only the current path (DFS uses stack)
  Time: O(b^d) — same as A* in practice (nodes at depth d dominate)
  
  Used in: puzzle solvers (15-puzzle, Rubik's cube)
  where the graph is ENORMOUS but solutions aren't too deep</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">ida_star_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    IDA* — Iterative Deepening A*
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Memory-efficient version of A*.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Uses DFS with f-value cutoff, increasing cutoff iteratively.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Space: O(d) where d = solution depth (vs O(V) for A*)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Time:  O(b^d) same as A* in practice
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Ideal when:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Graph is too large for A*'s open_set
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Solution depth is bounded
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Branching factor is manageable
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    rows</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> cols </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    gr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> gc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> goal
</span><span>    directions </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">h</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gr</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token builtin">abs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>c </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> gc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">search</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> g</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> f_limit</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        DFS with f-value cutoff.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Returns:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          - Distance if goal found
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          - Next f_limit to try if not found
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> path</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        f </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> h</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> f </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> f_limit</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> f  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># pruned — return this f as candidate for next threshold</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>r</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># found! (using -1 as sentinel for "found")</span><span>
</span>        
<span>        min_exceeded </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> dc </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> directions</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> r </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> dc
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nr </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> rows </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;=</span><span> nc </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> cols</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> grid</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nc</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> path_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    path_set</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                    
<span>                    result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> search</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> f_limit</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                    
<span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> result </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># goal found</span><span>
</span>                    
<span>                    min_exceeded </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">min</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>min_exceeded</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> result</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                    
<span>                    path</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>pop</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    path_set</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>remove</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nr</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> nc</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> min_exceeded
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Main IDA* loop ───</span><span>
</span><span>    path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    path_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    f_limit </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> h</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">*</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> search</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>path</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> f_limit</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> result </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>path</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>path</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># found!</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> result </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># no path exists</span><span>
</span>        
<span>        f_limit </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> result  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># increase threshold</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span>grid </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'S'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'#'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'.'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'G'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span></span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>
<span>dist</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> ida_star_grid</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>grid</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"IDA* distance: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">dist</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, path length: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation builtin">len</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">path</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h2>STEP 12: CONNECTIONS TO ALL PREVIOUS SHORTEST PATH ALGORITHMS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  THE COMPLETE SHORTEST PATH FAMILY TREE
  ═══════════════════════════════════════════════════════════════
  
  BFS (Problem 9)
    │ "All edges weight 1 → FIFO queue"
    │
    ├── 0-1 BFS (Problem 39)
    │     "Edges weight 0 or 1 → deque"
    │
    ├── Multi-source BFS (Problem 13)
    │     "Multiple starting points → all in queue initially"
    │
    ├── Bidirectional BFS (Problem 42)
    │     "Search from both ends → meet in middle"
    │
    └── Dijkstra (Problem 23)
          │ "Non-negative weights → priority queue by g(n)"
          │
          ├── A* (THIS PROBLEM)
          │     "Dijkstra + heuristic → priority queue by f(n) = g(n) + h(n)"
          │     │
          │     ├── Weighted A*
          │     │     "f(n) = g(n) + W×h(n), W &gt; 1 → faster but sub-optimal"
          │     │
          │     ├── IDA*
          │     │     "A* with O(d) memory via iterative deepening"
          │     │
          │     └── Bidirectional A*
          │           "A* from both ends"
          │
          └── Bellman-Ford (Problem 26)
                │ "Handles negative weights → relax all edges V-1 times"
                │
                └── Floyd-Warshall (Problem 33)
                      "All pairs shortest paths → O(V³)"
  
  DAG DP (Problem 47)
    "DAG structure → topological sort + relaxation → O(V+E)"
    "Beats ALL above for DAGs, handles negative weights"
  
  ═══════════════════════════════════════════════════════════════
  DECISION FLOWCHART
  ═══════════════════════════════════════════════════════════════
  
  Is graph a DAG?
  ├── YES → DAG DP (Problem 47) — O(V+E), always best for DAGs
  │
  └── NO → Are weights all non-negative?
      ├── NO → Bellman-Ford (Problem 26) — O(VE)
      │
      └── YES → Do you know the goal location?
          ├── NO → Dijkstra (Problem 23) — O((V+E) log V)
          │
          └── YES → Do you have a good heuristic?
              ├── NO → Dijkstra — can't benefit from A*
              │
              └── YES → A* (THIS PROBLEM)
                  │
                  ├── Memory OK? → Standard A*
                  └── Memory tight? → IDA*</code></pre></div>
<hr>
<h2>STEP 13: COMMON PITFALLS AND EDGE CASES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════╗
</span>  ║  PITFALL 1: Non-admissible heuristic                         ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  If h(n) &gt; actual distance for ANY node:                     ║
  ║    → A* may return a SUB-OPTIMAL path                        ║
  ║    → Silently wrong — no error, just longer path             ║
  ║                                                              ║
  ║  Common mistake: using Euclidean distance for 4-dir grid     ║
  ║    Euclidean distance IS admissible for 4-dir                ║
  ║    (Euclidean ≤ Manhattan always)                            ║
  ║    But using Manhattan for 8-dir grid:                       ║
  ║    Manhattan can OVERESTIMATE for diagonal moves!            ║
  ║                                                              ║
  ║  For 8-dir grid: use Chebyshev or octile distance instead   ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 2: Not handling duplicate entries in heap            ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  When we find a better path to a node:                       ║
  ║    → We push a new entry to the heap                         ║
  ║    → Old entry still exists (can't easily remove from heap)  ║
  ║    → When old entry is popped: g &gt; g_score[node]             ║
  ║    → Must SKIP it (lazy deletion)                            ║
  ║                                                              ║
  ║  Without this check: process stale entries → wrong answer    ║
  ║                                                              ║
  ║  FIX: Always check g &gt; g_score[(r,c)] after popping         ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 3: Using A* when Dijkstra/BFS suffices              ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  A* adds complexity (heuristic design, admissibility proof)  ║
  ║  If graph is small or heuristic is weak:                     ║
  ║    → BFS/Dijkstra is simpler and equally fast                ║
  ║                                                              ║
  ║  USE A* only when:                                           ║
  ║    → Graph is LARGE                                          ║
  ║    → You have a GOOD heuristic                               ║
  ║    → You need to reach ONE specific goal                     ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 4: Wrong heuristic for movement type                ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  4-directional grid: Manhattan distance                      ║
  ║    h = |Δr| + |Δc|                                          ║
  ║                                                              ║
  ║  8-directional grid (with diagonals): Chebyshev distance    ║
  ║    h = max(|Δr|, |Δc|)                                      ║
  ║                                                              ║
  ║  8-dir with diagonal cost √2: Octile distance               ║
  ║    h = max(|Δr|,|Δc|) + (√2-1) × min(|Δr|,|Δc|)           ║
  ║                                                              ║
  ║  Continuous space: Euclidean distance                        ║
  ║    h = √(Δr² + Δc²)                                        ║
  ║                                                              ║
  ║  Using wrong heuristic → either non-admissible or too loose ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Start equals goal                                ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  h(start) = 0, f = 0                                        ║
  ║  First pop: (0, 0, start) → goal check passes immediately  ║
  ║  Return distance 0, path = [start]                           ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Goal unreachable (surrounded by walls)           ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  A* exhausts all reachable nodes without finding goal.       ║
  ║  open_set becomes empty → return -1 (no path).              ║
  ║  Same behavior as Dijkstra/BFS.                              ║
  ╚══════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 14: REAL-WORLD APPLICATIONS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────┐
</span>  │  APPLICATION 1: GPS Navigation                                 │
  │                                                                │
  │  → Road network as weighted graph                              │
  │  → Nodes = intersections, edges = roads with travel times     │
  │  → Heuristic = straight-line distance / speed limit           │
  │  → A* finds fastest route exploring minimal road segments     │
  │  → Google Maps, Waze, Apple Maps all use A* variants          │
  └────────────────────────────────────────────────────────────────┘
  
  ┌────────────────────────────────────────────────────────────────┐
  │  APPLICATION 2: Video Game Pathfinding                         │
  │                                                                │
  │  → Game map as grid/navmesh                                   │
  │  → NPCs need to navigate around obstacles                     │
  │  → Must be FAST (real-time, many NPCs)                        │
  │  → Often use Weighted A* (W=1.5) for speed over optimality   │
  │  → Jump Point Search: A* optimization for uniform grids       │
  └────────────────────────────────────────────────────────────────┘
  
  ┌────────────────────────────────────────────────────────────────┐
  │  APPLICATION 3: Puzzle Solving (15-puzzle, Rubik's cube)       │
  │                                                                │
  │  → States = nodes, moves = edges                               │
  │  → Goal state known → heuristic possible                      │
  │  → 15-puzzle heuristic: sum of Manhattan distances of tiles   │
  │  → IDA* preferred (enormous state space, bounded depth)       │
  └────────────────────────────────────────────────────────────────┘
  
  ┌────────────────────────────────────────────────────────────────┐
  │  APPLICATION 4: Robotics Path Planning                         │
  │                                                                │
  │  → Configuration space as graph                                │
  │  → Robot needs to navigate physical space with obstacles      │
  │  → Heuristic = Euclidean distance in workspace                │
  │  → Often combined with RRT* (Rapidly-exploring Random Trees)  │
  └────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 15: HOW I WOULD RECOGNIZE THIS PATTERN IN AN INTERVIEW</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  "I see SHORTEST PATH with KNOWN GOAL LOCATION"                  │
  │       → A* is a candidate                                        │
  │       → Check: can I compute an admissible heuristic?            │
  │                                                                    │
  │  "The graph is very LARGE and I want to minimize exploration"     │
  │       → A* explores fewer nodes than Dijkstra                    │
  │       → Especially powerful on geometric graphs (grids, maps)    │
  │                                                                    │
  │  "I see a GRID with start and end positions"                      │
  │       → Grid has natural coordinates → Manhattan distance works  │
  │       → A* with Manhattan heuristic                              │
  │                                                                    │
  │  "I need to find path in a PUZZLE (known goal state)"            │
  │       → States = nodes, transitions = edges                      │
  │       → Heuristic based on goal state comparison                 │
  │       → IDA* if state space is huge                              │
  │                                                                    │
  │  WHEN NOT TO USE A*:                                              │
  │    → Graph is a DAG → use DAG DP (faster, simpler)              │
  │    → No meaningful heuristic → use Dijkstra                     │
  │    → Need shortest path to ALL nodes → use Dijkstra             │
  │    → Negative weights → use Bellman-Ford                        │
  │    → Graph is small → BFS/Dijkstra is simpler                   │
  │                                                                    │
  │  THINKING CHAIN:                                                   │
  │    "Shortest path to specific goal in large graph"               │
  │    → "Do I know goal's position/properties?"                     │
  │    → YES → "Can I compute lower bound on remaining distance?"   │
  │    → YES → "A* with that heuristic"                              │
  │    → "Is heuristic admissible? (never overestimates)"           │
  │    → YES → "A* guarantees optimal path"                          │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 16: KEY TAKEAWAY</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║   NEW CONCEPT LEARNED: A* SEARCH                                  ║
  ║                                                                    ║
  ║   1. CORE IDEA:                                                    ║
  ║      A* = Dijkstra + heuristic guidance                           ║
  ║      f(n) = g(n) + h(n)                                          ║
  ║      → g(n): actual cost from start (known)                      ║
  ║      → h(n): estimated cost to goal (heuristic)                  ║
  ║      → f(n): estimated total cost through this node              ║
  ║                                                                    ║
  ║   2. ADMISSIBILITY IS KEY:                                        ║
  ║      h(n) must NEVER overestimate                                ║
  ║      → Guarantees A* finds the optimal (shortest) path           ║
  ║      → Manhattan distance is admissible for 4-dir grids          ║
  ║                                                                    ║
  ║   3. PRACTICAL ADVANTAGE:                                         ║
  ║      Same worst-case as Dijkstra: O((V+E) log V)                ║
  ║      But explores FAR fewer nodes in practice                    ║
  ║      → Guided toward goal instead of exploring all directions    ║
  ║                                                                    ║
  ║   4. THE SEARCH ALGORITHM SPECTRUM:                               ║
  ║      BFS → Dijkstra → A*                                         ║
  ║      (no info) (cost info) (cost + goal info)                    ║
  ║      Each adds more information → more efficient search          ║
  ║                                                                    ║
  ║   5. WHEN TO USE:                                                  ║
  ║      ✓ Known goal location + good heuristic + large graph        ║
  ║      ✗ No heuristic → Dijkstra                                   ║
  ║      ✗ DAG → DAG DP (Problem 47)                                 ║
  ║      ✗ Negative weights → Bellman-Ford (Problem 26)              ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>CONNECTION TO NEXT PROBLEM</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Problem 48: A* Search — informed search with heuristics
</span>    → Uses graph structure (edges) + problem knowledge (heuristic)
    → Finds optimal paths by guiding search toward goal
    
  Problem 49: 2-SAT (Satisfiability via SCC)
    → A completely different use of graphs!
    → Models a LOGIC problem as a graph
    → Uses Strongly Connected Components (Problem 36)
    → "Can this Boolean formula be satisfied?"
    → Implication graph: if X then Y becomes edge X → Y
    → SCC analysis determines satisfiability
    
  The bridge:
    Problems 43-48: finding PATHS in graphs (flow, matching, 
                    ancestors, DP, search)
    Problems 49-50: using graph STRUCTURE to solve non-graph 
                    problems (logic, tree decomposition)
    
  This shows the ultimate power of graph algorithms:
    "Model ANY problem as a graph → apply graph algorithms → solve"</code></pre></div>
<hr>
<p><strong>Problem 48 Complete.</strong><br>
<strong>Ready for Problem 49: 2-SAT (Satisfiability via SCC)?</strong><br>
<em>Please confirm to proceed.</em></p></div>
</div>

<!-- ========== data-index="21" ========== -->

        </div>

        <div class="nav-bar">
            <a href="problem-47.html" class="nav-button prev">← Previous Problem</a>
            <div class="page-info">
                <a href="index.html" class="nav-button home">📚 Table of Contents</a><br>
                <span style="margin-top:8px;display:block">Problem 48 of 50</span>
            </div>
            <a href="problem-49.html" class="nav-button next">Next Problem →</a>
        </div>
    </div>

    
    <div id="progress-track"><div id="progress-fill"></div></div>
    <div id="progress-pct">0%</div>


    <script>
    const fill = document.getElementById('progress-fill');
    const pct  = document.getElementById('progress-pct');
    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrolled  = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        fill.style.height = scrolled + '%';
        pct.textContent   = Math.round(scrolled) + '%';
    }
    window.addEventListener('scroll', updateProgress);
    updateProgress();

    document.addEventListener('keydown', function(e) {
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
        if (e.key === 'ArrowLeft') {
            const b = document.querySelector('.nav-button.prev');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
        if (e.key === 'ArrowRight') {
            const b = document.querySelector('.nav-button.next');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
    });
    </script>

</body>
</html>