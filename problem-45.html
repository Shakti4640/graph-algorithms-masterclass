<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 45: Problem 45: Lowest Common Ancestor (Binary Lifting) — Graph Algorithms Mastery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.75;
            color: #1a202c;
            background-color: #f7fafc;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.08);
            padding: 48px 52px;
        }
        
        .content { max-width: 950px; margin: 0 auto; color: #1a202c; }
        .content h1 {
            color: #1a202c; margin: 32px 0 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #10b981;
            font-size: 2.1em;
            font-weight: 700;
        }
        .content h2 {
            color: #1a202c; margin: 28px 0 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #34d399;
            font-size: 1.6em;
            font-weight: 600;
        }
        .content h3 { color: #1a202c; margin: 22px 0 12px; font-size: 1.3em; font-weight: 600; }
        .content h4 { color: #2d3748; margin: 18px 0 10px; font-size: 1.1em; font-weight: 600; }
        .content p  { margin-bottom: 16px; line-height: 1.8; color: #1a202c; }
        .content ul, .content ol { margin: 12px 0 18px 30px; color: #1a202c; }
        .content li { margin-bottom: 8px; line-height: 1.75; color: #1a202c; }
        .content hr { border: none; border-top: 2px solid #e2e8f0; margin: 26px 0; }
        .content pre {
            background: #f7fafc !important;
            border: 1px solid #cbd5e0 !important;
            border-left: 4px solid #10b981 !important;
            padding: 18px !important; overflow-x: auto; margin: 18px 0; border-radius: 6px;
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.9em !important;
        }
        .content pre:not([style*="color"]) { color: #1a202c !important; }
        .content code {
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.88em !important;
        }
        .content code:not(pre code) {
            background: #d1fae5 !important;
            color: #1a202c !important;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .content pre code { background: transparent !important; padding: 0; }
        .content table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .content th {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white; padding: 12px 16px; text-align: left;
            font-weight: 600;
        }
        .content td { padding: 11px 16px; border: 1px solid #e2e8f0; color: #1a202c; }
        .content tr:nth-child(even) td { background: #ecfdf5; }
        .content blockquote {
            border-left: 4px solid #10b981; background: #ecfdf5;
            padding: 14px 20px; margin: 18px 0; border-radius: 0 6px 6px 0;
            color: #1a202c;
        }
        .content strong { color: #1a202c; font-weight: 600; }
        .px-2 { padding: 0; }
        .chat-message { background: transparent; padding: 0; margin: 0; }

        /* Bottom nav bar only */
        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 24px 0;
            margin-top: 50px;
            border-top: 3px solid #34d399;
        }
        .nav-button {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 12px 26px;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white !important; text-decoration: none;
            border-radius: 8px; font-weight: 600; font-size: 0.95em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16,185,129,0.35);
        }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 4px 14px rgba(16,185,129,0.5); }
        .nav-button.disabled { background: #cbd5e1; box-shadow: none; pointer-events: none; }
        .nav-button.home {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 2px 8px rgba(99,102,241,0.35);
        }
        .nav-button.home:hover { box-shadow: 0 4px 14px rgba(99,102,241,0.5); }
        .page-info { color: #718096; font-size: 0.9em; text-align: center; }

        /* Progress bar */
        #progress-track {
            position: fixed; top: 20px; right: 20px;
            width: 10px; height: 150px;
            background: rgba(16,185,129,0.2);
            border: 2px solid #10b981;
            border-radius: 6px; overflow: hidden; z-index: 1000;
        }
        #progress-fill {
            width: 100%;
            background: linear-gradient(180deg, #10b981, #059669);
            height: 0%;
            transition: height 0.15s ease;
        }
        #progress-pct {
            position: fixed; top: 0px; right: 16px;
            color: #059669; font-size: 14px; font-weight: bold;
            z-index: 1001;
            text-shadow: 0 1px 2px rgba(255,255,255,0.9);
            line-height: 20px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="chat-message" data-index="5">
<div class="px-2"><h1>Problem 45: Lowest Common Ancestor (Binary Lifting)</h1>
<h2>[Algorithm Family: Binary Lifting / Sparse Table on Trees]</h2>
<h2>[Phase 5: Expert — "I can design solutions for novel graph problems"]</h2>
<hr>
<h2>PROBLEM STATEMENT</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>You manage a large corporate hierarchy (a tree of employees).
</span>The CEO is at the root. Every other employee has exactly one manager.

Given this hierarchy and MANY queries of the form:
  "Who is the lowest-level manager that manages BOTH employee X 
   and employee Y (directly or indirectly)?"

This is the Lowest Common Ancestor (LCA).

Input:
  n = 10 (employees numbered 0 to 9, where 0 is the CEO/root)
  parent relationships forming a tree
  queries = [(7, 9), (5, 8), (3, 4), (6, 9)]

Output:
  LCA(7, 9) = 1
  LCA(5, 8) = 0
  LCA(3, 4) = 1
  LCA(6, 9) = 3

Constraints:
  → Up to 200,000 nodes
  → Up to 200,000 queries
  → Must answer EACH query in O(log N) after preprocessing</code></pre></div>
<hr>
<h2>STEP 1: VISUALIZE FIRST — Draw the Tree</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>                    0  (CEO)
</span>                   / \
                  /   \
                 1     2
                /|\     \
               / | \     \
              3  4  5     6
             / \         / \
            7   8       9   (no child)
            
  Edges (parent → child):
    0 → 1,  0 → 2
    1 → 3,  1 → 4,  1 → 5
    2 → 6
    3 → 7,  3 → 8
    6 → 9</code></pre></div>
<h3>Identify Graph Properties</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>╔═══════════════════════════════════════════════════════════════════╗
</span>║  Property        │  Answer          │  Why?                      ║
╠══════════════════╪══════════════════╪════════════════════════════╣
║  NODES           │  Employees 0-9   │  Each person = node        ║
║  EDGES           │  Manager-report  │  Parent-child connections  ║
║  Directed?       │  Rooted tree     │  Parent → child hierarchy  ║
║  Weighted?       │  NO              │  No weights needed for LCA ║
║  Cyclic?         │  NO              │  Trees are always acyclic  ║
║  Connected?      │  YES             │  One tree = one component  ║
║  Special         │  TREE            │  N nodes, N-1 edges,       ║
║                  │                  │  unique path between any 2 ║
╚══════════════════╧══════════════════╧════════════════════════════╝</code></pre></div>
<h3>What is LCA Visually?</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  LCA(7, 9) = ?
</span>  
  Path from 7 to root: 7 → 3 → 1 → 0
  Path from 9 to root: 9 → 6 → 2 → 0
  
                    0  ← both paths meet here
                   / \
                  1   2
                 /     \
                3       6
               /         \
              7           9
  
  But wait — they meet at 0. Is there anything LOWER?
  
  Actually let me re-check. 7's ancestors: {3, 1, 0}
                            9's ancestors: {6, 2, 0}
  
  Common ancestors: {0}
  LOWEST common ancestor: 0
  
  Hmm, let me adjust the tree to make better examples...
  
  Let me use a different tree:

                    0
                   / \
                  1    2
                / | \    \
               3   4  5    6
              / \         / \
             7   8       9   10

  LCA(7, 8) = ?
    7's ancestors: 3, 1, 0
    8's ancestors: 3, 1, 0
    Common: {3, 1, 0}
    LOWEST: 3  ✓  (3 is deepest common ancestor)

  LCA(7, 9) = ?
    7's ancestors: 3, 1, 0
    9's ancestors: 6, 2, 0
    Common: {0}
    LOWEST: 0  ✓

  LCA(7, 4) = ?
    7's ancestors: 3, 1, 0
    4's ancestors: 1, 0
    Common: {1, 0}
    LOWEST: 1  ✓

  LCA(7, 3) = ?
    7's ancestors: 3, 1, 0
    3 IS an ancestor of 7!
    LOWEST: 3  ✓  (one node CAN be the LCA of itself and descendant)</code></pre></div>
<h3>The Core Question</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Given a tree with N nodes and Q queries (u, v):
</span>  → For each query, find the deepest node that is 
    an ancestor of BOTH u and v
    
  Naive: O(N) per query → O(N × Q) total
  Goal:  O(log N) per query → O((N + Q) × log N) total</code></pre></div>
<hr>
<h2>STEP 2: BRUTE FORCE FIRST — Naive Approaches</h2>
<h3>Approach 1: Walk Up from Both Nodes</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  For LCA(u, v):
</span>    1. Find all ancestors of u (walk to root)       → O(depth_u)
    2. Walk up from v, checking if each ancestor 
       of v is in u's ancestor set                  → O(depth_v)
    3. First match = LCA

  Example: LCA(7, 4)
    Ancestors of 7: {7, 3, 1, 0}    (stored in set)
    Walk from 4: 
      Is 4 in set? NO
      Is 1 in set? YES → LCA = 1  ✓</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># BRUTE FORCE — O(N) per query</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">lca_naive</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>parent</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Step 1: collect all ancestors of u</span><span>
</span><span>    ancestors_u </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> u
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> node </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        ancestors_u</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Step 2: walk up from v until we hit an ancestor of u</span><span>
</span><span>    node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> v
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> ancestors_u</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> node</span></code></pre></div>
<h3>Approach 2: Equalize Depths, Then Walk Together</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  For LCA(7, 4):
</span>    depth[7] = 3,  depth[4] = 2
    
    Step 1: Bring deeper node UP to same depth
      7 is deeper → move 7 up by 1 → node becomes 3
      Now: node_a = 3 (depth 2), node_b = 4 (depth 2)
    
    Step 2: Walk both up simultaneously until they meet
      3 ≠ 4 → move both up
      parent[3] = 1, parent[4] = 1
      1 == 1 → LCA = 1  ✓</code></pre></div>
<h3>Why Brute Force Fails</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Per query: O(depth) which can be O(N) for skewed trees
</span>  
  Skewed tree (worst case):
    0 → 1 → 2 → 3 → ... → 199,999
    
    LCA(199999, 0):
      → Walk up 199,999 steps
      
  With 200,000 queries:
    → 200,000 × 200,000 = 4 × 10^10 operations
    → FAR TOO SLOW
    
  We need: O(log N) per query
  Key insight: instead of walking up ONE STEP at a time,
               JUMP in powers of 2!</code></pre></div>
<hr>
<h2>STEP 3: IDENTIFYING THE PATTERN</h2>
<h3>The Binary Lifting Idea</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  CORE INSIGHT:
</span>  
  Instead of knowing just parent[node] (1 step up),
  what if we precomputed:
  
    up[node][0] = parent of node              (2⁰ = 1 step up)
    up[node][1] = grandparent of node         (2¹ = 2 steps up)
    up[node][2] = great-great-grandparent     (2² = 4 steps up)
    up[node][3] = 8 steps up                  (2³ = 8 steps up)
    ...
    up[node][k] = 2^k-th ancestor of node

  Then to go UP by any number of steps, we decompose 
  that number into powers of 2 (binary representation)!

  Example: Go up 13 steps
    13 = 8 + 4 + 1 = 2³ + 2² + 2⁰
    → Jump 8, then jump 4, then jump 1
    → Only 3 jumps instead of 13 steps!
    
  In general: go up N steps → at most log₂(N) jumps
  
  This is BINARY LIFTING — "lifting" a node upward using 
  binary (power-of-2) jumps.</code></pre></div>
<h3>The Recurrence</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  up[node][0] = parent[node]
</span>  up[node][k] = up[ up[node][k-1] ][k-1]    for k ≥ 1
  
  WHY?
  
  The 2^k-th ancestor = 
    go 2^(k-1) steps up, then go another 2^(k-1) steps up
    
  Because: 2^(k-1) + 2^(k-1) = 2^k
  
  Example:
    up[node][2] = up[ up[node][1] ][1]
    
    "4th ancestor = grandparent's grandparent"
    
    Visually for node 7, finding 4th ancestor:
    
      up[7][0] = 3      (parent)
      up[7][1] = up[up[7][0]][0] = up[3][0] = 1    (grandparent)
      up[7][2] = up[up[7][1]][1] = up[1][1] = ?
                 up[1][1] = up[up[1][0]][0] = up[0][0] = -1 (root's parent)
      
      So up[7][2] = -1 (doesn't exist — 7 is only 3 levels deep)</code></pre></div>
<h3>LCA Algorithm Using Binary Lifting</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  LCA(u, v):
</span>  
  Step 1: EQUALIZE DEPTHS using binary jumps
    If depth[u] &gt; depth[v], swap so u is deeper
    Jump u up by (depth[u] - depth[v]) using binary lifting
    
  Step 2: CHECK if they're the same now
    If u == v → return u  (one was ancestor of other)
    
  Step 3: JUMP TOGETHER from highest power down
    For k from LOG down to 0:
      If up[u][k] ≠ up[v][k]:
        u = up[u][k]
        v = up[v][k]
    
    After this: u and v are ONE step below the LCA
    Return parent[u]

  WHY Step 3 works:
    We try the LARGEST possible jump first
    If jumping that far makes u and v meet → we OVERSHOOT
      (their LCA might be lower) → so we DON'T jump
    If jumping that far and they're STILL different → safe to jump
      (LCA is even higher) → so we DO jump
    
    After trying all powers, u and v are RIGHT BELOW the LCA</code></pre></div>
<hr>
<h2>STEP 4: ALGORITHM WALKTHROUGH</h2>
<h3>Setup: Build the Tree</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>                    0  (root, depth 0)
</span>                   / \
                  1    2              (depth 1)
                / | \    \
               3   4  5    6          (depth 2)
              / \         / \
             7   8       9   10       (depth 3)

  parent = [-1, 0, 0, 1, 1, 1, 2, 3, 3, 6, 6]
  depth  = [ 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]
  
  N = 11, LOG = ⌊log₂(11)⌋ + 1 = 4
  (we need ancestors up to 2³ = 8 steps, which covers depth up to 8)</code></pre></div>
<h3>Step A: Precompute the Binary Lifting Table</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Initialize up[node][0] = parent[node] for all nodes:
</span>
  up table (k=0, direct parents):
  ┌──────┬───────────────────────────────────────────┐
  │ k=0  │ node: 0  1  2  3  4  5  6  7  8  9  10  │
  │      │ par: -1  0  0  1  1  1  2  3  3  6   6  │
  └──────┴───────────────────────────────────────────┘

  Compute k=1 (2 steps up = grandparent):
  up[node][1] = up[ up[node][0] ][0]
  
  up[0][1] = up[-1][0]  → -1 (no grandparent, root)
  up[1][1] = up[ 0][0]  = -1 (parent of 0 = none)
  up[2][1] = up[ 0][0]  = -1
  up[3][1] = up[ 1][0]  =  0 (grandparent of 3 is 0)
  up[4][1] = up[ 1][0]  =  0
  up[5][1] = up[ 1][0]  =  0
  up[6][1] = up[ 2][0]  =  0
  up[7][1] = up[ 3][0]  =  1 (grandparent of 7 is 1)
  up[8][1] = up[ 3][0]  =  1
  up[9][1] = up[ 6][0]  =  2
  up[10][1]= up[ 6][0]  =  2

  ┌──────┬───────────────────────────────────────────┐
  │ k=1  │ node: 0  1  2  3  4  5  6  7  8  9  10  │
  │      │ anc: -1 -1 -1  0  0  0  0  1  1  2   2  │
  └──────┴───────────────────────────────────────────┘

  Compute k=2 (4 steps up):
  up[node][2] = up[ up[node][1] ][1]
  
  up[0][2] = up[-1][1] = -1
  up[1][2] = up[-1][1] = -1
  up[2][2] = up[-1][1] = -1
  up[3][2] = up[ 0][1] = -1  (0's grandparent doesn't exist)
  up[4][2] = up[ 0][1] = -1
  up[5][2] = up[ 0][1] = -1
  up[6][2] = up[ 0][1] = -1
  up[7][2] = up[ 1][1] = -1  (1's grandparent is root's parent = none)
  up[8][2] = up[ 1][1] = -1
  up[9][2] = up[ 2][1] = -1
  up[10][2]= up[ 2][1] = -1

  ┌──────┬───────────────────────────────────────────┐
  │ k=2  │ node: 0  1  2  3  4  5  6  7  8  9  10  │
  │      │ anc: -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  -1  │
  └──────┴───────────────────────────────────────────┘
  (All -1 because tree is shallow — max depth 3, can't go 4 steps up)

  Compute k=3 (8 steps up): all -1 (same reason)

  COMPLETE BINARY LIFTING TABLE:
  ┌──────┬────────────────────────────────────────┐
  │      │  0   1   2   3   4   5   6   7   8   9  10│
  ├──────┼────────────────────────────────────────┤
  │ k=0  │ -1   0   0   1   1   1   2   3   3   6   6│
  │ k=1  │ -1  -1  -1   0   0   0   0   1   1   2   2│
  │ k=2  │ -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1│
  │ k=3  │ -1  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1│
  └──────┴────────────────────────────────────────┘
  
  Reading: up[7][0] = 3  → 7's parent is 3
           up[7][1] = 1  → 7's grandparent is 1
           up[9][1] = 2  → 9's grandparent is 2</code></pre></div>
<hr>
<h3>Step B: Answer Query LCA(7, 9)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>                    0
</span>                   / \
                  1    2
                / | \    \
               3   4  5    6
              / \         / \
            [7]  8       [9] 10

  u = 7, v = 9
  depth[7] = 3, depth[9] = 3

  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  depth[7] = 3, depth[9] = 3
  Difference = 0 → already equal! No lifting needed.
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  u = 7, v = 9 → NOT same, continue
  
  ═══════════════════════════════════════════════════
  PHASE 3: BINARY LIFT TOGETHER (from k=3 down to k=0)
  ═══════════════════════════════════════════════════
  
  k=3: up[7][3] = -1, up[9][3] = -1
       -1 == -1 → they MEET → DON'T jump (would overshoot)
       u = 7, v = 9 (unchanged)
       
  k=2: up[7][2] = -1, up[9][2] = -1
       -1 == -1 → they MEET → DON'T jump
       u = 7, v = 9 (unchanged)
       
  k=1: up[7][1] = 1, up[9][1] = 2
       1 ≠ 2 → they're DIFFERENT → SAFE to jump!
       u = 1, v = 2
       
       Visually:
                    0
                   / \
                 [1]  [2]       ← jumped here
                / | \    \
               3   4  5    6
              / \         / \
             7    8       9   10
       
  k=0: up[1][0] = 0, up[2][0] = 0
       0 == 0 → they MEET → DON'T jump (would overshoot)
       u = 1, v = 2 (unchanged)
  
  ═══════════════════════════════════════════════════
  PHASE 4: ANSWER
  ═══════════════════════════════════════════════════
  
  u and v are now ONE step below LCA
  LCA = parent[u] = parent[1] = 0
  
  ANSWER: LCA(7, 9) = 0  ✓
  
  Verification:
    7's ancestors: 3, 1, 0
    9's ancestors: 6, 2, 0
    Deepest common: 0  ✓</code></pre></div>
<hr>
<h3>Step C: Answer Query LCA(7, 4)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>                    0
</span>                   / \
                  1    2
                / | \    \
               3  [4] 5    6
              / \         / \
            [7]  8       9   10

  u = 7, v = 4
  depth[7] = 3, depth[4] = 2

  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  diff = depth[7] - depth[4] = 3 - 2 = 1
  
  Binary of 1 = "1" → jump 2⁰ = 1 step
  
  k=0: bit is set → u = up[7][0] = 3
  
  Now: u = 3 (depth 2), v = 4 (depth 2) → equalized!
  
       Visually:
                    0
                   / \
                  1    2
                / | \    \
              [3] [4] 5    6
              / \         / \
             7    8       9   10
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  u = 3, v = 4 → NOT same, continue
  
  ═══════════════════════════════════════════════════
  PHASE 3: BINARY LIFT TOGETHER
  ═══════════════════════════════════════════════════
  
  k=3: up[3][3] = -1, up[4][3] = -1 → equal → don't jump
  k=2: up[3][2] = -1, up[4][2] = -1 → equal → don't jump
  k=1: up[3][1] = 0,  up[4][1] = 0  → equal → don't jump
  k=0: up[3][0] = 1,  up[4][0] = 1  → equal → don't jump
  
  u = 3, v = 4 (unchanged through all k)
  
  ═══════════════════════════════════════════════════
  PHASE 4: ANSWER
  ═══════════════════════════════════════════════════
  
  LCA = parent[u] = parent[3] = 1
  
  ANSWER: LCA(7, 4) = 1  ✓</code></pre></div>
<hr>
<h3>Step D: Answer Query LCA(7, 3) — Ancestor Case</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  u = 7, v = 3
</span>  depth[7] = 3, depth[3] = 2

  PHASE 1: EQUALIZE
  diff = 1 → lift u by 1: u = up[7][0] = 3
  
  PHASE 2: CHECK
  u = 3, v = 3 → SAME!
  
  ANSWER: LCA(7, 3) = 3  ✓
  
  Key: when one node IS the ancestor, equalizing makes them meet!</code></pre></div>
<hr>
<h3>Step E: Larger Example — Why Binary Jumps Matter</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Imagine a chain (skewed tree):
</span>  0 → 1 → 2 → 3 → ... → 15

  depth[15] = 15, depth[3] = 3
  
  Naive: walk 15 up to 3 = 12 steps
  
  Binary lifting: 
    diff = 12 = 8 + 4 = 2³ + 2²
    Jump 2³ = 8: node 15 → node 7      (1 jump)
    Jump 2² = 4: node 7  → node 3      (1 jump)
    Done in 2 jumps instead of 12 steps!
    
  For diff = 100,000:
    100,000 in binary ≈ 17 bits
    At most 17 jumps instead of 100,000 steps!</code></pre></div>
<hr>
<h2>STEP 5: COMPLETE CODE</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">import</span><span> sys
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> deque
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> math </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> log2
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">LCABinaryLifting</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Lowest Common Ancestor using Binary Lifting.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Preprocessing: O(N log N) time and space
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Each query:    O(log N) time
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Built on concepts from:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 1:  Adjacency list representation
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 3:  BFS for depth computation
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 4:  DFS for tree traversal
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 46: Will extend this for Tree DP
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">__init__</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Build the binary lifting table for LCA queries.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Args:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            n: number of nodes (0 to n-1)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            edges: list of [u, v] undirected edges forming a tree
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            root: root node of the tree
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> n
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> root
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── LOG computation ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># We need ancestors up to 2^LOG steps</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># LOG = floor(log2(n)) + 1 covers any possible depth</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>log2</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">else</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Build adjacency list (Problem 1) ───</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Arrays to fill ───</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n          </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># depth of each node</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>parent </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># direct parent</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># up[node][k] = 2^k-th ancestor of node</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># -1 means "no such ancestor" (went above root)</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> _ </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Step 1: BFS to find depth and parent ───</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>_bfs_setup</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Step 2: Fill binary lifting table ───</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>_build_lifting_table</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">_bfs_setup</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        BFS from root to compute depth[] and parent[] for all nodes.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Why BFS? 
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          - Processes nodes level by level (Problem 3)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          - Guarantees parent is processed before child
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          - Works for any tree structure (balanced, skewed, etc.)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>n
</span><span>        queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node
</span><span>                    queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">_build_lifting_table</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Fill up[node][k] for all nodes and all k.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Base case:  up[node][0] = parent[node]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Recurrence: up[node][k] = up[ up[node][k-1] ][k-1]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        "The 2^k-th ancestor is the 2^(k-1)-th ancestor 
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">         of the 2^(k-1)-th ancestor."
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Time:  O(N × LOG) = O(N log N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Space: O(N × LOG) = O(N log N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Base case: k = 0 → direct parent</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Fill k = 1, 2, ..., LOG-1</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                ancestor </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> ancestor </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Already above root — no 2^k-th ancestor</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">else</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 2^k-th ancestor = 2^(k-1)-th ancestor of 2^(k-1)-th ancestor</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>ancestor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">lift</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> steps</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Move 'node' up by 'steps' ancestors using binary jumps.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Decompose 'steps' into powers of 2 and jump accordingly.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Example: steps = 13 = 8 + 4 + 1
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          → jump 8 (k=3), jump 4 (k=2), jump 1 (k=0)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          → 3 jumps instead of 13 single steps
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Returns -1 if we go above the root.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> node </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> steps </span><span class="token" style="color: rgb(57, 58, 52);">&amp;</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;&lt;</span><span> k</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># if k-th bit is set</span><span>
</span><span>                node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> node
</span>    
    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">query</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Find LCA of nodes u and v.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Three phases:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          1. Equalize depths (lift deeper node up)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          2. If same → one is ancestor of other → return
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          3. Binary lift both until one step below LCA
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Time: O(log N) per query
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Phase 1: Equalize depths ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Make u the deeper node for simplicity</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Lift u up to same depth as v</span><span>
</span><span>        diff </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        u </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>lift</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> diff</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Phase 2: Same node? ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> u </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># One was the ancestor of the other</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> u
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Phase 3: Binary lift together ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Try jumps from LARGEST to SMALLEST</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># If jumping makes them equal → DON'T jump (would overshoot)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># If jumping keeps them different → DO jump (LCA is higher)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                u </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                v </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Now u and v are ONE step below LCA</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># = parent[u] = parent[v] = LCA</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ══════════════════════════════════════════════════════════════</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  USAGE AND TESTING</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ══════════════════════════════════════════════════════════════</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">solve</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Build the tree from the visualization:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                    0
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                   / \
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                  1    2
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                / | \    \
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">               3   4  5    6
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">              / \         / \
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">             7   8       9   10
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">11</span><span>
</span><span>    edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>           </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># root's children</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>   </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># node 1's children</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>                    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># node 2's child</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>           </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># node 3's children</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>           </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># node 6's children</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Build LCA structure — O(N log N) preprocessing</span><span>
</span><span>    lca </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> LCABinaryLifting</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Print the computed tables</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">"Depths:"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">"Parents:"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">"Binary Lifting Table (up[node][k] = 2^k-th ancestor):"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'node'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">:</span><span class="token string-interpolation interpolation format-spec">&lt;6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(163, 21, 21);">""</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'k='</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">+</span><span class="token string-interpolation interpolation builtin">str</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">k</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">:</span><span class="token string-interpolation interpolation format-spec">&lt;6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(163, 21, 21);">""</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">node</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">:</span><span class="token string-interpolation interpolation format-spec">&lt;6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(163, 21, 21);">""</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            val </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">val</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">:</span><span class="token string-interpolation interpolation format-spec">&lt;6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(163, 21, 21);">""</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Answer queries — O(log N) each</span><span>
</span><span>    queries </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> queries</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> lca</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>query</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"LCA(</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">u</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">v</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">) = </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">result</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>

<span>solve</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<p><strong>Output:</strong></p>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>Depths: [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]
</span>Parents: [-1, 0, 0, 1, 1, 1, 2, 3, 3, 6, 6]

Binary Lifting Table (up[node][k] = 2^k-th ancestor):
node  k=0   k=1   k=2   k=3   
0     -1    -1    -1    -1    
1     0     -1    -1    -1    
2     0     -1    -1    -1    
3     1     0     -1    -1    
4     1     0     -1    -1    
5     1     0     -1    -1    
6     2     0     -1    -1    
7     3     1     -1    -1    
8     3     1     -1    -1    
9     6     2     -1    -1    
10    6     2     -1    -1    

LCA(7, 9) = 0
LCA(7, 4) = 1
LCA(7, 3) = 3
LCA(7, 8) = 3
LCA(4, 5) = 1
LCA(9, 10) = 6
LCA(8, 10) = 0</code></pre></div>
<hr>
<h3>Version 2: LCA with Distance Computation</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">LCAWithDistance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>LCABinaryLifting</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Extension: Also compute the DISTANCE between two nodes.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    distance(u, v) = depth[u] + depth[v] - 2 * depth[LCA(u,v)]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Why? The path from u to v goes:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      u → LCA → v
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Length = (depth[u] - depth[LCA]) + (depth[v] - depth[LCA])
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">             = depth[u] + depth[v] - 2 * depth[LCA]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Useful for:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Finding path length between any two nodes in O(log N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Checking if a node lies on the path between two others
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Distance (number of edges) between u and v in the tree."""</span><span>
</span><span>        ancestor </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>query</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>ancestor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">is_on_path</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> x</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Check if node x lies on the path from u to v.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        x is on path(u,v) if and only if:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">          distance(u, x) + distance(x, v) == distance(u, v)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> x</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>x</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── USAGE ───</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">test_distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">11</span><span>
</span><span>    edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    lca </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> LCAWithDistance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#       0</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#      / \</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#     1   2</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#    /|\    \</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   3 4 5    6</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  /\       /\</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 7  8     9  10</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"distance(7, 9) = </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">lca</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">distance</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">7</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">9</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Path: 7→3→1→0→2→6→9 = 6 edges</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"distance(7, 8) = </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">lca</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">distance</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">7</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">8</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Path: 7→3→8 = 2 edges</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"distance(7, 4) = </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">lca</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">distance</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">7</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">4</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Path: 7→3→1→4 = 3 edges</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Is node 1 on path(7, 4)? </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">lca</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">is_on_path</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">1</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">7</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">4</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># True</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Is node 2 on path(7, 4)? </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">lca</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">is_on_path</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">2</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">7</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">4</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># False</span><span>
</span>

<span>test_distance</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<p><strong>Output:</strong></p>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>distance(7, 9) = 6
</span>distance(7, 8) = 2
distance(7, 4) = 3
Is node 1 on path(7, 4)? True
Is node 2 on path(7, 4)? False</code></pre></div>
<hr>
<h3>Version 3: LCA for Weighted Trees (Path Sum Queries)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">LCAWeighted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>LCABinaryLifting</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Extension: Handle WEIGHTED trees.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Additional capability:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Sum of edge weights on the path between any two nodes
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Maximum edge weight on the path
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Uses same binary lifting but also precomputes:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      dist_to_root[node] = sum of weights from root to node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    path_weight(u, v) = dist_to_root[u] + dist_to_root[v] 
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">                        - 2 * dist_to_root[LCA(u,v)]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Connects to:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 23 (Dijkstra — single source, but here it's a tree)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 46 (Tree DP — will extend this pattern)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">__init__</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        weighted_edges: list of [u, v, weight]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Convert to unweighted edges for parent class</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># but also store weights in adjacency list</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>wadj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        unweighted_edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> weighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>wadj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>wadj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            unweighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Initialize parent class</span><span>
</span><span>        </span><span class="token builtin">super</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>__init__</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> unweighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Compute weighted distances from root</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>_compute_weighted_distances</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">_compute_weighted_distances</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""BFS computing sum of edge weights from root to each node."""</span><span>
</span><span>        visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>n
</span><span>        queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weight </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>wadj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> weight
</span><span>                    queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">path_weight</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Sum of edge weights on path from u to v."""</span><span>
</span><span>        ancestor </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>query</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> 
</span><span>                </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>dist_to_root</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>ancestor</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h2>STEP 6: COMPLEXITY ANALYSIS</h2>
<h3>Preprocessing</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────┐
</span>  │  Operation                    │  Time      │  Space    │
  ├──────────────────────────────┼────────────┼──────────┤
  │  Build adjacency list         │  O(N)      │  O(N)    │
  │  BFS for depth/parent         │  O(N)      │  O(N)    │
  │  Build lifting table          │  O(N logN) │  O(N logN)│
  │  (N nodes × LOG levels)       │            │          │
  ├──────────────────────────────┼────────────┼──────────┤
  │  TOTAL PREPROCESSING          │  O(N logN) │  O(N logN)│
  └──────────────────────────────┴────────────┴──────────┘
  
  WHY O(N log N)?
  
  The lifting table has N rows and LOG ≈ log₂(N) columns.
  Each cell computed in O(1): up[node][k] = up[up[node][k-1]][k-1]
  Total: N × log₂(N) cells × O(1) each = O(N log N)</code></pre></div>
<h3>Per Query</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────┐
</span>  │  Phase                        │  Time                  │
  ├──────────────────────────────┼────────────────────────┤
  │  Equalize depths (lift)       │  O(log N) — at most    │
  │                               │  LOG binary jumps      │
  │  Binary lift together         │  O(log N) — iterate    │
  │                               │  from LOG-1 down to 0  │
  ├──────────────────────────────┼────────────────────────┤
  │  TOTAL PER QUERY              │  O(log N)              │
  └──────────────────────────────┴────────────────────────┘
  
  WHY O(log N)?
  
  Equalizing: decompose depth difference into at most log₂(N) bits
  Lifting together: try at most log₂(N) jump sizes
  Total: 2 × log₂(N) = O(log N)</code></pre></div>
<h3>Total for Q Queries</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Preprocessing:     O(N log N)
</span>  All Q queries:     O(Q log N)
  TOTAL:             O((N + Q) log N)
  
  Compare with naive:
    O(N × Q) — for large N and Q, this is MUCH worse
    
  Example: N = 200,000 and Q = 200,000
    Naive:          200,000 × 200,000 = 4 × 10^10  (TLE)
    Binary Lifting: (200,000 + 200,000) × 17 ≈ 7 × 10^6  (FAST)</code></pre></div>
<hr>
<h2>STEP 7: THE DEEP INTUITION — WHY BINARY LIFTING WORKS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  ANALOGY: Express Elevator vs Regular Elevator
  ═══════════════════════════════════════════════════════════════
  
  Regular elevator: goes 1 floor at a time
    Floor 100 → Floor 0 = 100 stops
    
  Express elevator system:
    Elevator A: jumps 1 floor     (2⁰)
    Elevator B: jumps 2 floors    (2¹)
    Elevator C: jumps 4 floors    (2²)
    Elevator D: jumps 8 floors    (2³)
    Elevator E: jumps 16 floors   (2⁴)
    Elevator F: jumps 32 floors   (2⁵)
    Elevator G: jumps 64 floors   (2⁶)
    
  Floor 100 → Floor 0:
    Take G (64 floors): 100 → 36
    Take F (32 floors): 36 → 4
    Take C (4 floors):  4 → 0
    
    3 rides instead of 100!
    
  This is EXACTLY binary lifting:
    up[node][k] = the "elevator that jumps 2^k floors"
    
  ANY number can be decomposed into at most log₂(N) powers of 2
  (that's what binary representation IS)
  
  ═══════════════════════════════════════════════════════════════
  WHY THE LCA PHASE 3 WORKS (the tricky part)
  ═══════════════════════════════════════════════════════════════
  
  After equalizing depths, u and v are at the same depth.
  The LCA is some number of steps above them.
  
  We DON'T know how many steps. But we can FIND OUT:
  
  Try k = LOG-1 (biggest jump):
    If up[u][k] == up[v][k]: 
      → jumping this far OVERSHOOTS past the LCA
      → LCA is BELOW this level
      → DON'T jump
    If up[u][k] != up[v][k]:
      → even after jumping, they haven't met
      → LCA is ABOVE this level  
      → DO jump (get closer)
  
  This is like BINARY SEARCH on the distance to LCA!
  
  After all k from LOG-1 to 0:
    We've narrowed down to EXACTLY one step below LCA.
    
  Think of it as:
    "I'm determining the distance to LCA bit by bit,
     from the most significant bit to the least significant bit."
     
  ═══════════════════════════════════════════════════════════════
  THE INVARIANT
  ═══════════════════════════════════════════════════════════════
  
  After Phase 3, the following is ALWAYS true:
    up[u][0] == up[v][0]       (parents are same = LCA)
    u ≠ v                       (they're different nodes)
    
  So the answer is simply parent[u] = parent[v] = LCA.</code></pre></div>
<hr>
<h2>STEP 8: ALTERNATIVE LCA METHODS — COMPARISON</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌───────────────────┬──────────────┬─────────────┬──────────────┐
</span>  │  Method           │  Preprocess  │  Per Query  │  Space       │
  ├───────────────────┼──────────────┼─────────────┼──────────────┤
  │  Naive (walk up)  │  O(N)        │  O(N)       │  O(N)        │
  │  Binary Lifting   │  O(N log N)  │  O(log N)   │  O(N log N)  │
  │  Euler Tour + RMQ │  O(N)        │  O(1)       │  O(N)        │
  │  Tarjan's Offline │  O(N + Q)    │  offline    │  O(N + Q)    │
  └───────────────────┴──────────────┴─────────────┴──────────────┘
  
  Binary Lifting is the SWEET SPOT:
    ✓ Easy to implement (compared to Euler Tour + Sparse Table RMQ)
    ✓ Online queries (answer as they come)
    ✓ O(log N) per query is fast enough for almost all problems
    ✓ Easily extendable (path sums, path max, etc.)
    ✓ Works as a building block for many tree algorithms
    
  When to use Euler Tour + RMQ instead:
    → Need O(1) per query (millions of queries)
    → More complex to implement but theoretically optimal
    
  When to use Tarjan's offline:
    → Know ALL queries in advance
    → Uses Union-Find (Problem 27) cleverly</code></pre></div>
<hr>
<h2>STEP 9: CONNECTIONS TO PREVIOUS AND FUTURE PROBLEMS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌─────────────────────────────────────────────────────────────────┐
</span>  │  BUILDS ON:                                                     │
  │                                                                 │
  │  Problem 1:  Adjacency list to store the tree                  │
  │  Problem 3:  BFS to compute depths and parents                 │
  │  Problem 4:  DFS alternative for tree traversal                │
  │  Problem 27: Union-Find (Tarjan's offline LCA uses it)         │
  │  Problem 34: Tarjan's algorithm — similar disc/low concept     │
  │              of tracking ancestry information                   │
  │  Problem 44: Bipartite matching — trees are special bipartite  │
  │              graphs; LCA helps in tree-based matching           │
  ├─────────────────────────────────────────────────────────────────┤
  │  ENABLES:                                                       │
  │                                                                 │
  │  Problem 46: Tree DP — LCA helps decompose tree paths          │
  │  Problem 47: Graph DP on DAGs — similar "ancestor" reasoning   │
  │  Problem 50: Centroid decomposition — LCA is a prerequisite    │
  │              for many centroid decomposition applications       │
  │                                                                 │
  │  Beyond this guide:                                             │
  │    → Heavy-Light Decomposition (uses LCA as subroutine)        │
  │    → Path queries (sum/max/min on tree paths)                  │
  │    → Virtual tree construction                                 │
  │    → Tree isomorphism                                          │
  └─────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 10: COMMON PITFALLS AND EDGE CASES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════════╗
</span>  ║  PITFALL 1: Off-by-one in LOG computation                       ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  WRONG: LOG = int(log2(n))                                      ║
  ║    → For n=8: LOG=3, but we need k=0,1,2,3 (4 levels)          ║
  ║                                                                  ║
  ║  RIGHT: LOG = int(log2(n)) + 1                                  ║
  ║    → Ensures we cover the maximum possible depth                ║
  ║                                                                  ║
  ║  SAFEST: LOG = 20 for n ≤ 10^6  (2^20 &gt; 10^6)                  ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 2: Not handling -1 (sentinel for "above root")         ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  When up[node][k] = -1 and you try up[-1][k-1]:                 ║
  ║    → Index -1 in Python accesses LAST element (silent bug!)     ║
  ║                                                                  ║
  ║  FIX: Always check for -1 before using as index                 ║
  ║    if ancestor == -1:                                            ║
  ║        up[node][k] = -1                                          ║
  ║    else:                                                         ║
  ║        up[node][k] = up[ancestor][k-1]                           ║
  ║                                                                  ║
  ║  ALT FIX: Use node n as sentinel, with up[n][k] = n for all k  ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 3: Forgetting to swap u,v when equalizing depths       ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  Must ensure the DEEPER node gets lifted                        ║
  ║  If you lift the shallower node → goes ABOVE root → crash       ║
  ║                                                                  ║
  ║  FIX: Always swap so depth[u] &gt;= depth[v] before lifting        ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 4: LCA(u, u) — same node query                        ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  depth diff = 0, after equalization u == v → return u           ║
  ║  Should work, but verify your code handles it!                  ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 5: Root is not always node 0                           ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  Some problems give root = 1 or root = arbitrary node           ║
  ║  Make sure BFS/DFS starts from the correct root                 ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Single node tree (n=1)                              ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  LCA(0, 0) = 0                                                  ║
  ║  LOG = max(1, ...) handles this                                  ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Skewed tree (linked list)                           ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  0 → 1 → 2 → ... → N-1                                         ║
  ║  Max depth = N-1                                                 ║
  ║  LOG = log₂(N) ≈ 17 for N=200,000                               ║
  ║  Binary lifting shines here: 17 jumps vs 200,000 walks          ║
  ╚══════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 11: PRACTICAL APPLICATIONS OF LCA</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  APPLICATION 1: Distance Between Any Two Nodes in a Tree
  ═══════════════════════════════════════════════════════════════
  
  dist(u, v) = depth[u] + depth[v] - 2 × depth[LCA(u,v)]
  
  Why? Path goes u → LCA → v
       = (depth[u] - depth[LCA]) + (depth[v] - depth[LCA])
  
  ═══════════════════════════════════════════════════════════════
  APPLICATION 2: Path Sum/Max/Min Between Two Nodes
  ═══════════════════════════════════════════════════════════════
  
  Extend binary lifting to also store:
    sum_up[node][k] = sum of weights going 2^k steps up from node
    max_up[node][k] = max weight going 2^k steps up from node
  
  Then combine during the LCA query.
  
  ═══════════════════════════════════════════════════════════════
  APPLICATION 3: Checking if Node X is Ancestor of Node Y
  ═══════════════════════════════════════════════════════════════
  
  X is ancestor of Y ⟺ LCA(X, Y) == X
  
  ═══════════════════════════════════════════════════════════════
  APPLICATION 4: K-th Ancestor Query
  ═══════════════════════════════════════════════════════════════
  
  "What is the k-th ancestor of node u?"
  → Just use lift(u, k) directly!
  → O(log N) per query
  
  ═══════════════════════════════════════════════════════════════
  APPLICATION 5: Finding the Path Between Two Nodes
  ═══════════════════════════════════════════════════════════════
  
  path(u, v) = path(u, LCA) + path(LCA, v)
  → Useful for marking edges, counting specific edges, etc.</code></pre></div>
<hr>
<h2>STEP 12: COMPLETE TRACED EXAMPLE ON A DEEPER TREE</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Tree (depth 5, to show binary lifting power):
</span>  
        0
        |
        1
       / \
      2    3
     /      \
    4        5
   / \      / \
  6   7    8   9
  |        |
  10       11

  n = 12
  edges: 0-1, 1-2, 1-3, 2-4, 3-5, 4-6, 4-7, 5-8, 5-9, 6-10, 8-11
  
  Depths:  [0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5]
  Parents: [-1, 0, 1, 1, 2, 3, 4, 4, 5, 5, 6, 8]
  
  LOG = floor(log2(12)) + 1 = 3 + 1 = 4
  
  Binary Lifting Table:
  ┌──────┬────┬────┬────┬────┐
  │ node │k=0 │k=1 │k=2 │k=3 │
  ├──────┼────┼────┼────┼────┤
  │  0   │ -1 │ -1 │ -1 │ -1 │
  │  1   │  0 │ -1 │ -1 │ -1 │
  │  2   │  1 │  0 │ -1 │ -1 │
  │  3   │  1 │  0 │ -1 │ -1 │
  │  4   │  2 │  1 │ -1 │ -1 │
  │  5   │  3 │  1 │ -1 │ -1 │
  │  6   │  4 │  2 │  0 │ -1 │
  │  7   │  4 │  2 │  0 │ -1 │
  │  8   │  5 │  3 │  0 │ -1 │
  │  9   │  5 │  3 │  0 │ -1 │
  │ 10   │  6 │  4 │  1 │ -1 │
  │ 11   │  8 │  5 │  1 │ -1 │
  └──────┴────┴────┴────┴────┘
  
  Verify up[10][2]:
    up[10][2] = up[ up[10][1] ][1] = up[4][1] = 1  ✓
    (10's 4th ancestor: 10→6→4→2→1, but 2^2 = 4th ancestor = 1? 
     Let's count: 10→6 (1), 6→4 (2), 4→2 (3), 2→1 (4). Yes, 4th ancestor = 1) ✓
  
  ─────────────────────────────────────
  QUERY: LCA(10, 11)
  ─────────────────────────────────────
  
  depth[10] = 5, depth[11] = 5 → already equal


        0
        |
        1
       / \
      2    3
     /      \
    4        5
   / \      / \
  6   7    8   9
  |        |
  10       11

  Binary Lifting Table (reminder):
  ┌──────┬────┬────┬────┬────┐
  │ node │k=0 │k=1 │k=2 │k=3 │
  ├──────┼────┼────┼────┼────┤
  │  0   │ -1 │ -1 │ -1 │ -1 │
  │  1   │  0 │ -1 │ -1 │ -1 │
  │  2   │  1 │  0 │ -1 │ -1 │
  │  3   │  1 │  0 │ -1 │ -1 │
  │  4   │  2 │  1 │ -1 │ -1 │
  │  5   │  3 │  1 │ -1 │ -1 │
  │  6   │  4 │  2 │  0 │ -1 │
  │  7   │  4 │  2 │  0 │ -1 │
  │  8   │  5 │  3 │  0 │ -1 │
  │  9   │  5 │  3 │  0 │ -1 │
  │ 10   │  6 │  4 │  1 │ -1 │
  │ 11   │  8 │  5 │  1 │ -1 │
  └──────┴────┴────┴────┴────┘
  
  Depths: [0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5]</code></pre></div>
<hr>
<h3>QUERY: LCA(10, 11)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  u = 10, v = 11
</span>  depth[10] = 5, depth[11] = 5
  
  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  diff = 5 - 5 = 0 → already equal, no lifting needed
  u = 10, v = 11
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  10 ≠ 11 → continue to Phase 3
  
  ═══════════════════════════════════════════════════
  PHASE 3: BINARY LIFT TOGETHER
  ═══════════════════════════════════════════════════
  
  k=3: up[10][3] = -1,  up[11][3] = -1
       -1 == -1 → EQUAL → DON'T jump (would overshoot past LCA)
       u = 10, v = 11
       
  k=2: up[10][2] = 1,   up[11][2] = 1
       1 == 1 → EQUAL → DON'T jump
       u = 10, v = 11
       
       WHY don't we jump?
       If we jumped both to node 1, we'd be AT or ABOVE the LCA.
       But we want to land ONE STEP BELOW the LCA.
       Jumping here would lose information about WHERE exactly 
       the LCA is — it might be below node 1.
       
  k=1: up[10][1] = 4,   up[11][1] = 5
       4 ≠ 5 → DIFFERENT → DO jump!
       u = up[10][1] = 4
       v = up[11][1] = 5
       
       Visually after this jump:
       
             0
             |
             1          ← LCA must be HERE or above
            / \
          [4]  [5]      ← we're here now (one level apart from meeting)
          / \  / \
         6  7 8  9
         |    |
        10   11
       
  k=0: up[4][0] = 2,    up[5][0] = 3
       2 ≠ 3 → DIFFERENT → DO jump!
       u = up[4][0] = 2
       v = up[5][0] = 3
       
       Visually after this jump:
       
             0
             |
             1          ← LCA must be HERE
            / \
          [2] [3]       ← we're here now
          /     \
         4       5
        / \     / \
       6   7   8   9
       |       |
      10      11
       
  All k exhausted.
  
  ═══════════════════════════════════════════════════
  PHASE 4: ANSWER
  ═══════════════════════════════════════════════════
  
  u = 2, v = 3 → one step below LCA
  LCA = parent[u] = parent[2] = 1
  
  ANSWER: LCA(10, 11) = 1  ✓
  
  Verification:
    10's ancestors: 6, 4, 2, 1, 0
    11's ancestors: 8, 5, 3, 1, 0
    Common: {1, 0}
    DEEPEST common: 1  ✓
    
  Total jumps made: 2 (at k=1 and k=0)
  Naive would have walked: 10→6→4→2→1 AND 11→8→5→3→1 = 8 steps</code></pre></div>
<hr>
<h3>QUERY: LCA(10, 7)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  u = 10, v = 7
</span>  depth[10] = 5, depth[7] = 4
  
  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  u is deeper → keep u = 10
  diff = 5 - 4 = 1
  
  Binary of 1 = "0001"
  
  k=0: bit 0 is SET → u = up[10][0] = 6
  k=1: bit 1 is NOT set → skip
  k=2: bit 2 is NOT set → skip
  k=3: bit 3 is NOT set → skip
  
  After equalization: u = 6 (depth 4), v = 7 (depth 4)
  
  Visually:
  
        0
        |
        1
       / \
      2    3
     /      \
    4        5
   / \      / \
 [6] [7]   8   9
  |        |
  10       11
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  6 ≠ 7 → continue
  
  ═══════════════════════════════════════════════════
  PHASE 3: BINARY LIFT TOGETHER
  ═══════════════════════════════════════════════════
  
  k=3: up[6][3] = -1,   up[7][3] = -1
       -1 == -1 → EQUAL → don't jump
       
  k=2: up[6][2] = 0,    up[7][2] = 0
       0 == 0 → EQUAL → don't jump
       
  k=1: up[6][1] = 2,    up[7][1] = 2
       2 == 2 → EQUAL → don't jump
       
       NOTE: even though they'd meet at node 2, the LCA
       might be LOWER (node 4 is the actual LCA!)
       So we correctly DON'T jump.
       
  k=0: up[6][0] = 4,    up[7][0] = 4
       4 == 4 → EQUAL → don't jump
       
  u = 6, v = 7 (unchanged through ALL of Phase 3)
  
  ═══════════════════════════════════════════════════
  PHASE 4: ANSWER
  ═══════════════════════════════════════════════════
  
  LCA = parent[6] = 4
  
  ANSWER: LCA(10, 7) = 4  ✓
  
  Verification:
    10's ancestors: 6, 4, 2, 1, 0
    7's ancestors:  4, 2, 1, 0
    Common: {4, 2, 1, 0}
    DEEPEST common: 4  ✓
    
  KEY INSIGHT from this example:
    When u and v are SIBLINGS (same parent), Phase 3
    makes NO jumps at all. Every jump level shows them meeting,
    so we correctly stay put and return their common parent.</code></pre></div>
<hr>
<h3>QUERY: LCA(10, 9)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  u = 10, v = 9
</span>  depth[10] = 5, depth[9] = 4
  
  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  diff = 5 - 4 = 1 → lift u by 1
  k=0: u = up[10][0] = 6
  
  Now: u = 6 (depth 4), v = 9 (depth 4)
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  6 ≠ 9 → continue
  
  ═══════════════════════════════════════════════════
  PHASE 3: BINARY LIFT TOGETHER
  ═══════════════════════════════════════════════════
  
  k=3: up[6][3] = -1,   up[9][3] = -1 → equal → skip
  k=2: up[6][2] = 0,    up[9][2] = 0  → equal → skip
  k=1: up[6][1] = 2,    up[9][1] = 3
       2 ≠ 3 → DIFFERENT → jump!
       u = 2, v = 3
       
  k=0: up[2][0] = 1,    up[3][0] = 1
       1 == 1 → equal → skip
  
  u = 2, v = 3
  
  ═══════════════════════════════════════════════════
  PHASE 4: ANSWER
  ═══════════════════════════════════════════════════
  
  LCA = parent[2] = 1
  
  ANSWER: LCA(10, 9) = 1  ✓
  
  Verification:
    10's ancestors: 6, 4, 2, 1, 0
    9's ancestors:  5, 3, 1, 0
    Deepest common: 1  ✓</code></pre></div>
<hr>
<h3>QUERY: LCA(10, 4) — Ancestor Case</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  u = 10, v = 4
</span>  depth[10] = 5, depth[4] = 3
  
  ═══════════════════════════════════════════════════
  PHASE 1: EQUALIZE DEPTHS
  ═══════════════════════════════════════════════════
  
  diff = 5 - 3 = 2
  Binary of 2 = "10"
  
  k=0: bit 0 NOT set → skip
  k=1: bit 1 IS set  → u = up[10][1] = 4
  
  Now: u = 4 (depth 3), v = 4 (depth 3)
  
  ═══════════════════════════════════════════════════
  PHASE 2: CHECK IF SAME
  ═══════════════════════════════════════════════════
  
  u = 4, v = 4 → SAME! → return 4
  
  ANSWER: LCA(10, 4) = 4  ✓
  
  Node 4 IS an ancestor of node 10:
    10 → 6 → 4
    
  When one node is ancestor of the other,
  Phase 1 brings the deeper node UP to the shallower one,
  and they become identical → Phase 2 catches this.</code></pre></div>
<hr>
<h2>STEP 13: COMPETITIVE PROGRAMMING OPTIMIZED VERSION</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">import</span><span> sys
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span>
<span></span><span class="token builtin">input</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> sys</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>stdin</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>readline
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">solve_competitive</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Competitive programming version:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    - Faster I/O
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    - Fixed LOG = 20 (covers n up to 10^6)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    - Array-based (no classes)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    - Handles 1-indexed nodes (common in competitive programming)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Problem format:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Line 1: N Q (nodes, queries)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Line 2: parent[2], parent[3], ..., parent[N]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">              (parent of node i, 1-indexed, root = 1)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Next Q lines: u v (LCA query)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    LOG </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">20</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 2^20 &gt; 10^6, covers all practical sizes</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Read Input ───</span><span>
</span><span>    n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> q </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">map</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">input</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>split</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Build adjacency list (1-indexed)</span><span>
</span><span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> _ </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    parents_input </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">map</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">input</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>split</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        p </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> parents_input</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>p</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>p</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── BFS for depth and parent ───</span><span>
</span><span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    parent </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    root </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>    queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>    parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># sentinel: root has no parent</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node
</span><span>                queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Build binary lifting table ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># up[k][node] — transposed for cache efficiency</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># (iterating over nodes for fixed k is common)</span><span>
</span><span>    up </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> _ </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Base case</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Fill higher levels</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Note: up[k-1][0] = 0, so going above root stays at 0</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Using 0 as sentinel instead of -1 simplifies this</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Answer queries ───</span><span>
</span><span>    output </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> _ </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>q</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">map</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token builtin">input</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>split</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Ensure u is deeper</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;</span><span> depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> u
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Phase 1: equalize depths</span><span>
</span><span>        diff </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> depth</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> diff </span><span class="token" style="color: rgb(57, 58, 52);">&amp;</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;&lt;</span><span> k</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                u </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Phase 2: same node?</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> u </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            output</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">str</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Phase 3: binary lift together</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>LOG </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                u </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                v </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Phase 4: answer</span><span>
</span><span>        output</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">str</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Batch output for speed</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'\n'</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>join</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>output</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<h3>Key Optimization Notes</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │  OPTIMIZATION                │  WHY                          │
  ├──────────────────────────────┼────────────────────────────────┤
  │  up[k][node] instead of     │  Cache-friendly: when we fix k │
  │  up[node][k]                │  and iterate nodes, they're    │
  │                              │  contiguous in memory          │
  ├──────────────────────────────┼────────────────────────────────┤
  │  Sentinel 0 instead of -1   │  No boundary checks needed!    │
  │  (up[0][k] = 0 for all k)  │  Going above root just stays   │
  │                              │  at 0 forever — harmless       │
  ├──────────────────────────────┼────────────────────────────────┤
  │  Fixed LOG = 20              │  No log2 computation needed    │
  │                              │  Works for n ≤ 10^6           │
  │                              │  Wastes ~20×n ints at most    │
  ├──────────────────────────────┼────────────────────────────────┤
  │  Batch output                │  Single print at end is much   │
  │                              │  faster than Q separate prints │
  ├──────────────────────────────┼────────────────────────────────┤
  │  sys.stdin.readline          │  10-100x faster than input()   │
  └──────────────────────────────┴────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 14: THE SENTINEL TRICK — DEEP EXPLANATION</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  USING 0 AS SENTINEL (Competitive Programming Style)
  ═══════════════════════════════════════════════════════════════
  
  Problem with -1 sentinel:
    up[node][k] = up[ up[node][k-1] ][k-1]
    If up[node][k-1] = -1 → up[-1][k-1] → INDEX ERROR!
    
    Must add: if up[node][k-1] == -1: up[node][k] = -1
    Extra branch in inner loop = slower
  
  Solution: Use node 0 as a "virtual root above the real root"
    parent[real_root] = 0
    parent[0] = 0           ← 0 points to itself!
    up[0][k] = 0 for all k  ← jumping from 0 always stays at 0
    
    Now: up[node][k] = up[ up[node][k-1] ][k-1]
    If up[node][k-1] = 0 → up[0][k-1] = 0 → stays at 0
    NO BOUNDARY CHECK NEEDED!
    
  In the LCA query, 0 never equals any real node (real nodes 1..N)
  so the comparison up[u][k] != up[v][k] works correctly.
  
  When both u and v reach 0 → up[u][k] == up[v][k] == 0 → don't jump
  This is equivalent to "both went above root" → correct behavior.
  
  Visually:
  
    [0] ← virtual sentinel (not a real node)
     |
     1  ← actual root
    / \
   2   3
   ...</code></pre></div>
<hr>
<h2>STEP 15: WHEN TO USE WHICH LCA METHOD</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌───────────────────────┬──────────────────────────────────────────┐
</span>  │  Scenario             │  Best Method                             │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  Few queries (Q &lt; N)  │  Naive O(N) per query is fine           │
  │                       │  No preprocessing needed                 │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  Many online queries  │  BINARY LIFTING (this problem)          │
  │  (standard case)      │  O(N log N) preprocess, O(log N) query  │
  │                       │  Easy to code, easy to extend            │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  Need O(1) queries    │  Euler Tour + Sparse Table RMQ          │
  │  (millions of queries)│  O(N) preprocess, O(1) query            │
  │                       │  Harder to code                          │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  All queries known    │  Tarjan's Offline LCA                   │
  │  in advance           │  O(N + Q × α(N)) ≈ O(N + Q)            │
  │                       │  Uses Union-Find (Problem 27)            │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  Need path queries    │  Binary Lifting + Extension             │
  │  (sum/max on path)    │  Store extra info in lifting table      │
  │                       │  Or use Heavy-Light Decomposition        │
  ├───────────────────────┼──────────────────────────────────────────┤
  │  Dynamic tree (edges  │  Link-Cut Trees (Splay-based)           │
  │  added/removed)       │  O(log N) amortized per operation       │
  │                       │  Very complex to implement               │
  └───────────────────────┴──────────────────────────────────────────┘
  
  RECOMMENDATION FOR INTERVIEWS: Binary Lifting
    → Covers 95% of LCA problems
    → Clean, systematic code
    → Easy to explain
    → Naturally extends to path queries</code></pre></div>
<hr>
<h2>STEP 16: EXTENSION — K-TH ANCESTOR (LEETCODE 1483)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">TreeAncestor</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LeetCode 1483: Kth Ancestor of a Tree Node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Given a tree and queries (node, k),
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    return the k-th ancestor of node, or -1 if doesn't exist.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is a DIRECT APPLICATION of binary lifting.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    No LCA query needed — just the lift() function!
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Connection: This is the SIMPLEST use of binary lifting.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LCA builds ON TOP of this by using lift() to equalize depths
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    and then adding the "binary lift together" phase.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">__init__</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">16</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># covers n up to 50,000</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> _ </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Base case</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Fill table</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> k </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>k </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">getKthAncestor</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> k</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Return k-th ancestor of node, or -1 if doesn't exist."""</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> bit </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>LOG</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> node </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> k </span><span class="token" style="color: rgb(57, 58, 52);">&amp;</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&lt;&lt;</span><span> bit</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>up</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>bit</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> node</span></code></pre></div>
<hr>
<h2>STEP 17: HOW I WOULD RECOGNIZE THIS PATTERN IN AN INTERVIEW</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  "I see a TREE with ANCESTOR QUERIES"                             │
  │       → LCA or k-th ancestor problem                              │
  │       → Binary lifting                                             │
  │                                                                    │
  │  "I need to find COMMON ANCESTOR of two nodes"                    │
  │       → Classic LCA                                                │
  │       → Binary lifting for O(log N) per query                     │
  │                                                                    │
  │  "I need DISTANCE between two nodes in a tree"                    │
  │       → LCA + depth formula:                                       │
  │         dist(u,v) = depth[u] + depth[v] - 2*depth[LCA(u,v)]      │
  │                                                                    │
  │  "I need to JUMP UP k levels from a node"                         │
  │       → Direct binary lifting (lift function)                      │
  │                                                                    │
  │  "I need SUM/MAX/MIN on PATH between two tree nodes"             │
  │       → Binary lifting with extra arrays                           │
  │       → Or Heavy-Light Decomposition                               │
  │                                                                    │
  │  "Is node X on the path from U to V?"                             │
  │       → LCA(U,V), then check if X is ancestor of U or V          │
  │         and below LCA                                              │
  │       → Or: dist(U,X) + dist(X,V) == dist(U,V)                   │
  │                                                                    │
  │  RECOGNITION SIGNALS:                                              │
  │    → Tree structure (N nodes, N-1 edges, connected, acyclic)      │
  │    → Multiple queries about pairs of nodes                         │
  │    → Words: "ancestor", "path between", "lowest manager"          │
  │    → Need better than O(N) per query                               │
  │                                                                    │
  │  THINKING CHAIN:                                                   │
  │    "Tree + pair queries" → "LCA needed"                           │
  │    → "Multiple queries" → "need preprocessing"                    │
  │    → "Binary lifting: O(N log N) preprocess, O(log N) query"     │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 18: WHAT IF THE GRAPH WERE...</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  WHAT IF: Not a tree but a GENERAL GRAPH?
  ═══════════════════════════════════════════════════════════════
  
  LCA is defined ONLY for trees (or forests).
  For general graphs, the concept doesn't apply directly.
  
  However, you can:
    → Build a BFS/DFS tree from the graph (Problem 3/4)
    → Run LCA on that tree
    → This is used in Tarjan's bridge-finding (Problem 34)
      where DFS tree + back edges reveal bridges
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: Forest (multiple trees)?
  ═══════════════════════════════════════════════════════════════
  
  Two nodes in DIFFERENT trees have no common ancestor.
  → Check: if root(u) ≠ root(v) → return -1 (no LCA)
  → Can use Union-Find (Problem 27) to check connectivity first
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: Weighted tree?
  ═══════════════════════════════════════════════════════════════
  
  LCA itself doesn't change (it's about structure, not weights).
  But we can EXTEND binary lifting to track path weights:
  
    weight_up[node][k] = sum of edge weights going 2^k steps up
    
    weight_up[node][0] = weight of edge from node to parent
    weight_up[node][k] = weight_up[node][k-1] + weight_up[up[node][k-1]][k-1]
    
  Path weight query:
    → During equalization and binary lifting, accumulate weights
    
  ═══════════════════════════════════════════════════════════════
  WHAT IF: Tree changes dynamically?
  ═══════════════════════════════════════════════════════════════
  
  Binary lifting requires STATIC tree (precomputed table).
  For dynamic trees (edges added/removed):
    → Link-Cut Trees (advanced, O(log N) amortized)
    → Euler Tour Trees
    → Beyond scope of this guide, but know they exist</code></pre></div>
<hr>
<h2>STEP 19: THE COMPLETE MENTAL MODEL</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════════
</span>  BINARY LIFTING = "Express Elevator System for Trees"
  ═══════════════════════════════════════════════════════════════════
  
  PREPROCESS (build the elevator system):
  
    Level 0: Every node knows its parent        (1 step)
    Level 1: Every node knows its grandparent   (2 steps)
    Level 2: Every node knows its 4th ancestor  (4 steps)
    Level 3: Every node knows its 8th ancestor  (8 steps)
    ...
    Level k: Every node knows its 2^k-th ancestor
    
    Each level builds on the previous:
      "My 2^k ancestor = my 2^(k-1) ancestor's 2^(k-1) ancestor"
    
  QUERY (use the elevators):
  
    Phase 1: Take elevators to equalize heights
      → Decompose height difference into binary
      → Take corresponding elevators
      
    Phase 2: Take elevators TOGETHER (largest first)
      → If elevator takes us to same floor → DON'T take (overshoot)
      → If elevator keeps us on different floors → DO take
      → After all elevators tried → one floor below meeting point
      
    Phase 3: Take one more step up → LCA!
    
  ═══════════════════════════════════════════════════════════════════
  WHY "BINARY"?
  ═══════════════════════════════════════════════════════════════════
  
  Any integer can be represented in binary.
  Any number of steps can be decomposed into powers of 2.
  
  Steps = 42 = 32 + 8 + 2 = 2⁵ + 2³ + 2¹
  → Take elevator 5, then elevator 3, then elevator 1
  → 3 rides instead of 42 walks
  → In general: log₂(N) rides instead of N walks
  
  This is the SAME idea behind:
    → Binary search (halving search space)
    → Binary indexed trees / Fenwick trees
    → Sparse tables
    → Fast exponentiation (a^n in O(log n))
  
  COMMON THREAD: "Use powers of 2 to skip exponentially"</code></pre></div>
<hr>
<h2>STEP 20: KEY TAKEAWAY</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║   NEW CONCEPT LEARNED: BINARY LIFTING FOR LCA                    ║
  ║                                                                    ║
  ║   1. BINARY LIFTING TABLE:                                        ║
  ║      up[node][k] = 2^k-th ancestor of node                       ║
  ║      Recurrence: up[node][k] = up[up[node][k-1]][k-1]            ║
  ║      Build: O(N log N) time and space                             ║
  ║                                                                    ║
  ║   2. LCA QUERY in O(log N):                                       ║
  ║      → Equalize depths using binary jumps                         ║
  ║      → Binary lift together (don't overshoot)                     ║
  ║      → Return parent of final position                            ║
  ║                                                                    ║
  ║   3. EXTENSIBLE:                                                   ║
  ║      → K-th ancestor queries                                      ║
  ║      → Distance between tree nodes                                ║
  ║      → Path sum/max/min queries                                   ║
  ║      → Check if node is on path between two others                ║
  ║                                                                    ║
  ║   4. CORE PRINCIPLE: "Powers of 2 let us skip exponentially"     ║
  ║      → Same idea in binary search, sparse tables, fast expo      ║
  ║                                                                    ║
  ║   5. DECISION: Binary Lifting is the GO-TO for LCA               ║
  ║      → Simple to implement                                        ║
  ║      → O(log N) per query is fast enough for almost everything   ║
  ║      → Naturally extends to path queries                          ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>CONNECTION TO NEXT PROBLEM</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Problem 45: LCA via Binary Lifting
</span>    → Preprocessing on a tree for efficient ancestor queries
    → Foundation: BFS for depth, binary table for jumping
    
  Problem 46: Tree DP (Maximum Path Sum)
    → DFS traversal of tree + dynamic programming
    → "At each node, what's the best path through me?"
    → Combines DFS (Problem 4) with DP thinking
    → LCA (this problem) helps UNDERSTAND tree paths:
      any path in a tree goes "up to LCA, then down"
    → Tree DP computes optimal such paths efficiently</code></pre></div>
<hr>
</div>
</div>

<!-- ========== data-index="9" ========== -->

        </div>

        <div class="nav-bar">
            <a href="problem-44.html" class="nav-button prev">← Previous Problem</a>
            <div class="page-info">
                <a href="index.html" class="nav-button home">📚 Table of Contents</a><br>
                <span style="margin-top:8px;display:block">Problem 45 of 50</span>
            </div>
            <a href="problem-46.html" class="nav-button next">Next Problem →</a>
        </div>
    </div>

    
    <div id="progress-track"><div id="progress-fill"></div></div>
    <div id="progress-pct">0%</div>


    <script>
    const fill = document.getElementById('progress-fill');
    const pct  = document.getElementById('progress-pct');
    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrolled  = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        fill.style.height = scrolled + '%';
        pct.textContent   = Math.round(scrolled) + '%';
    }
    window.addEventListener('scroll', updateProgress);
    updateProgress();

    document.addEventListener('keydown', function(e) {
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
        if (e.key === 'ArrowLeft') {
            const b = document.querySelector('.nav-button.prev');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
        if (e.key === 'ArrowRight') {
            const b = document.querySelector('.nav-button.next');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
    });
    </script>

</body>
</html>