<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 42: Problem 42: Bidirectional BFS — Graph Algorithms Mastery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.75;
            color: #1a202c;
            background-color: #f7fafc;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.08);
            padding: 48px 52px;
        }
        
        .content { max-width: 950px; margin: 0 auto; color: #1a202c; }
        .content h1 {
            color: #1a202c; margin: 32px 0 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #10b981;
            font-size: 2.1em;
            font-weight: 700;
        }
        .content h2 {
            color: #1a202c; margin: 28px 0 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #34d399;
            font-size: 1.6em;
            font-weight: 600;
        }
        .content h3 { color: #1a202c; margin: 22px 0 12px; font-size: 1.3em; font-weight: 600; }
        .content h4 { color: #2d3748; margin: 18px 0 10px; font-size: 1.1em; font-weight: 600; }
        .content p  { margin-bottom: 16px; line-height: 1.8; color: #1a202c; }
        .content ul, .content ol { margin: 12px 0 18px 30px; color: #1a202c; }
        .content li { margin-bottom: 8px; line-height: 1.75; color: #1a202c; }
        .content hr { border: none; border-top: 2px solid #e2e8f0; margin: 26px 0; }
        .content pre {
            background: #f7fafc !important;
            border: 1px solid #cbd5e0 !important;
            border-left: 4px solid #10b981 !important;
            padding: 18px !important; overflow-x: auto; margin: 18px 0; border-radius: 6px;
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.9em !important;
        }
        .content pre:not([style*="color"]) { color: #1a202c !important; }
        .content code {
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.88em !important;
        }
        .content code:not(pre code) {
            background: #d1fae5 !important;
            color: #1a202c !important;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .content pre code { background: transparent !important; padding: 0; }
        .content table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .content th {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white; padding: 12px 16px; text-align: left;
            font-weight: 600;
        }
        .content td { padding: 11px 16px; border: 1px solid #e2e8f0; color: #1a202c; }
        .content tr:nth-child(even) td { background: #ecfdf5; }
        .content blockquote {
            border-left: 4px solid #10b981; background: #ecfdf5;
            padding: 14px 20px; margin: 18px 0; border-radius: 0 6px 6px 0;
            color: #1a202c;
        }
        .content strong { color: #1a202c; font-weight: 600; }
        .px-2 { padding: 0; }
        .chat-message { background: transparent; padding: 0; margin: 0; }

        /* Bottom nav bar only */
        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 24px 0;
            margin-top: 50px;
            border-top: 3px solid #34d399;
        }
        .nav-button {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 12px 26px;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white !important; text-decoration: none;
            border-radius: 8px; font-weight: 600; font-size: 0.95em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16,185,129,0.35);
        }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 4px 14px rgba(16,185,129,0.5); }
        .nav-button.disabled { background: #cbd5e1; box-shadow: none; pointer-events: none; }
        .nav-button.home {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 2px 8px rgba(99,102,241,0.35);
        }
        .nav-button.home:hover { box-shadow: 0 4px 14px rgba(99,102,241,0.5); }
        .page-info { color: #718096; font-size: 0.9em; text-align: center; }

        /* Progress bar */
        #progress-track {
            position: fixed; top: 20px; right: 20px;
            width: 10px; height: 150px;
            background: rgba(16,185,129,0.2);
            border: 2px solid #10b981;
            border-radius: 6px; overflow: hidden; z-index: 1000;
        }
        #progress-fill {
            width: 100%;
            background: linear-gradient(180deg, #10b981, #059669);
            height: 0%;
            transition: height 0.15s ease;
        }
        #progress-pct {
            position: fixed; top: 0px; right: 16px;
            color: #059669; font-size: 14px; font-weight: bold;
            z-index: 1001;
            text-shadow: 0 1px 2px rgba(255,255,255,0.9);
            line-height: 20px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="chat-message" data-index="19">
<div class="px-2"><h1>Problem 42: Bidirectional BFS</h1>
<h2>[Algorithm Family: BFS Optimization — Search from Both Ends]</h2>
<h2>[Phase 4: Advanced — "I can handle complex multi-concept problems"]</h2>
<hr>
<h2>PROBLEM STATEMENT</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>You are given a word puzzle. Transform a beginWord into an endWord
</span>by changing ONE letter at a time. Each intermediate word must exist
in the given wordList.

Find the LENGTH of the shortest transformation sequence.

This is the SAME problem as Word Ladder (Problem 15), but now:
  → The word list is HUGE (50,000+ words)
  → Standard BFS is too slow
  → We need an OPTIMIZATION

Input:
  beginWord = "hit"
  endWord   = "cog"
  wordList  = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation:
  hit → hot → dot → dog → cog  (5 words, 4 transformations)

Now imagine:
  wordList has 50,000 words, each of length 10
  Standard BFS explores MILLIONS of states
  Bidirectional BFS explores far fewer — WHY?</code></pre></div>
<hr>
<h2>STEP 1: VISUALIZE FIRST — The Explosion Problem</h2>
<h3>Standard BFS: One-Directional Search</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Start: "hit"
</span>  Goal:  "cog"

  BFS from "hit" expands outward like a CIRCLE:

  Level 0:  hit                                    1 node
  Level 1:  hot                                    ~1-3 nodes
  Level 2:  dot, lot                               ~3-9 nodes
  Level 3:  dog, log                               ~9-27 nodes
  Level 4:  cog ← FOUND!                           ~27-81 nodes

  Total explored: ~1 + 3 + 9 + 27 + 81 ≈ 121 nodes

  In general, if branching factor = b and depth = d:
    Total nodes explored ≈ b^d</code></pre></div>
<h3>The Problem with Large Graphs</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  For real-world word ladders:
</span>    → Word length = 10
    → Each position: 26 possible letters
    → Branching factor b ≈ 10-50 (many valid words per step)
    → Depth d ≈ 10-20 transformations

  Standard BFS: explores ≈ b^d nodes
    b=20, d=10 → 20^10 ≈ 10^13 → WAY TOO SLOW

  Bidirectional BFS: explores ≈ 2 × b^(d/2) nodes
    b=20, d=10 → 2 × 20^5 ≈ 6.4 × 10^6 → FAST!

  ┌────────────────────────────────────────────────────────────────┐
  │                                                                │
  │  STANDARD BFS:                                                 │
  │                                                                │
  │  start ─────────────────────────────────────→ goal             │
  │        ○                                                       │
  │       ○○○                                                      │
  │      ○○○○○                                                     │
  │     ○○○○○○○                                                    │
  │    ○○○○○○○○○                                                   │
  │   ○○○○○○○○○○○   ← explores THIS MANY nodes                   │
  │  ○○○○○○○○○○○○○                                                │
  │ ○○○○○○○○○○○○○○○                                               │
  │                                                                │
  │  Explored: b^d ≈ HUGE                                          │
  │                                                                │
  ├────────────────────────────────────────────────────────────────┤
  │                                                                │
  │  BIDIRECTIONAL BFS:                                            │
  │                                                                │
  │  start ──────→←────── goal                                     │
  │        ○             ○                                         │
  │       ○○○           ○○○                                        │
  │      ○○○○○         ○○○○○                                       │
  │     ○○○○○○○       ○○○○○○○                                      │
  │      ○○○○○ MEET! ○○○○○                                        │
  │        ↑               ↑                                       │
  │   front search    back search                                  │
  │                                                                │
  │  Explored: 2 × b^(d/2) ≈ MUCH SMALLER                        │
  │                                                                │
  └────────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>The Math: Why Bidirectional is Exponentially Better</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Standard BFS:
</span>    Explores ≈ b^d nodes
    
  Bidirectional BFS:
    Each side explores ≈ b^(d/2) nodes
    Total ≈ 2 × b^(d/2)
    
  SAVINGS:
    b^d  vs  2 × b^(d/2)
    
    b=10, d=10:
      Standard:     10^10 = 10,000,000,000
      Bidirectional: 2 × 10^5 = 200,000
      SPEEDUP: 50,000×

    b=20, d=10:
      Standard:     20^10 ≈ 10^13
      Bidirectional: 2 × 20^5 ≈ 6,400,000
      SPEEDUP: ~1,500,000×

    b=2, d=20:
      Standard:     2^20 = 1,048,576
      Bidirectional: 2 × 2^10 = 2,048
      SPEEDUP: 512×

  GENERAL: speedup = b^d / (2 × b^(d/2)) = b^(d/2) / 2
  → EXPONENTIAL speedup in the branching factor!</code></pre></div>
<h3>Identify Graph Properties</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║  Property        │  Answer                  │  Why?               ║
  ╠══════════════════╪══════════════════════════╪═════════════════════╣
  ║  NODES           │  Words in dictionary     │  Each word = state  ║
  ║  EDGES           │  One-letter differences  │  Can transform      ║
  ║  Directed?       │  NO                      │  Can go both ways   ║
  ║  Weighted?       │  NO (each step = 1)      │  Uniform cost       ║
  ║  Cyclic?         │  YES                     │  Can loop back      ║
  ║  Connected?      │  Maybe not               │  Some words isolated║
  ║  Implicit?       │  YES                     │  Built during search║
  ║  Special?        │  KNOW BOTH START AND END │  KEY for bidir BFS  ║
  ╚══════════════════╧══════════════════════════╧═════════════════════╝

  CRITICAL REQUIREMENT for Bidirectional BFS:
    → Must know BOTH the start AND the goal
    → If goal is unknown (e.g., "find nearest X"), bidir BFS won't work
    → Word Ladder: we know beginWord AND endWord → PERFECT fit</code></pre></div>
<hr>
<h2>STEP 2: BRUTE FORCE — Standard BFS (Problem 15 Recap)</h2>
<h3>Standard BFS Approach</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  From Problem 15 (Word Ladder):
</span>    → BFS from beginWord
    → At each level, try changing each position to each letter a-z
    → If resulting word is in wordList, add to next level
    → If we reach endWord, return the depth

  This works but explores ALL nodes up to depth d:
    → Total: O(b^d) where b = branching factor, d = depth
    → For large dictionaries: TOO SLOW</code></pre></div>
<h3>Why We Need Something Better</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Standard BFS explores a SPHERE of radius d around the start.
</span>  
  Volume of sphere grows as b^d (exponential in depth).
  
  Key observation:
    → We KNOW the target!
    → Instead of one sphere of radius d,
       use TWO spheres of radius d/2
    → Two small spheres have MUCH less total volume than one big sphere
    
  This is the FUNDAMENTAL insight of bidirectional BFS.</code></pre></div>
<hr>
<h2>STEP 3: IDENTIFYING THE GRAPH PATTERN</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  THINKING PROCESS:
</span>
  "Shortest path in unweighted graph"
    → BFS (Problem 9)

  "BFS is too slow because the search space explodes"
    → Need to PRUNE the search space
    → We know BOTH start and end → can search from BOTH sides

  "Search from both sides and meet in the middle"
    → BIDIRECTIONAL BFS
    → Each side does BFS up to depth d/2
    → When frontiers OVERLAP → found shortest path
    → Total depth = front_depth + back_depth

  WHEN TO USE:
    → Unweighted shortest path (BFS family)
    → Know both START and GOAL
    → Large branching factor (b &gt;&gt; 1)
    → Significant depth (d &gt;&gt; 1)
    → Speedup is exponential: b^d → 2 × b^(d/2)</code></pre></div>
<hr>
<h2>STEP 4: ALGORITHM WALKTHROUGH</h2>
<h3>The Bidirectional BFS Algorithm</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  1. Initialize TWO frontiers:
</span>     → front_set = {beginWord}    (searching FROM start)
     → back_set  = {endWord}      (searching FROM goal)
     
  2. Initialize visited sets for both sides:
     → front_visited = {beginWord}
     → back_visited  = {endWord}
     
  3. depth = 1 (start counts as step 1)

  4. While BOTH frontiers are non-empty:
     a. OPTIMIZATION: always expand the SMALLER frontier
        (this keeps both sides balanced, minimizing total exploration)
        
     b. Generate next level for the smaller frontier
     
     c. For each new word in next level:
        → If it appears in the OTHER side's visited set:
          → PATHS MEET! Return front_depth + back_depth
        → Otherwise, add to this side's visited set and new frontier
     
     d. depth += 1

  5. If either frontier becomes empty → no path exists → return 0</code></pre></div>
<h3>Step-by-Step Trace</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  beginWord = "hit"
</span>  endWord   = "cog"
  wordList  = ["hot","dot","dog","lot","log","cog"]

  word_set = {"hot","dot","dog","lot","log","cog"}</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │  INITIALIZATION:                                                   │
  │                                                                    │
  │  front_set = {"hit"}       ← searching FROM start                │
  │  back_set  = {"cog"}       ← searching FROM goal                 │
  │  front_visited = {"hit"}                                          │
  │  back_visited  = {"cog"}                                          │
  │  depth = 1                                                         │
  │                                                                    │
  │  Visual:                                                           │
  │                                                                    │
  │    [hit] ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ [cog]                  │
  │     F→                                     ←B                     │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │  ITERATION 1:                                                      │
  │                                                                    │
  │  |front_set| = 1, |back_set| = 1 → same size, expand front       │
  │                                                                    │
  │  Expand "hit":                                                     │
  │    Change pos 0: ait,bit,cit,...,zit → none in word_set           │
  │    Change pos 1: hat,hbt,...,hot,...,hzt → "hot" in word_set!     │
  │    Change pos 2: hia,hib,...,hiz → none in word_set               │
  │                                                                    │
  │    "hot" in back_visited? NO                                       │
  │    → Add "hot" to front_visited and new frontier                  │
  │                                                                    │
  │  front_set = {"hot"}                                               │
  │  front_visited = {"hit", "hot"}                                    │
  │  depth = 2                                                         │
  │                                                                    │
  │  Visual:                                                           │
  │                                                                    │
  │    hit ── hot ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ [cog]                      │
  │           F→                            ←B                        │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │  ITERATION 2:                                                      │
  │                                                                    │
  │  |front_set| = 1, |back_set| = 1 → same size, expand back        │
  │  (Let's alternate — expand the back side this time)               │
  │                                                                    │
  │  Expand "cog":                                                     │
  │    Change pos 0: aog,bog,...,dog,...,log,...,zog                   │
  │      → "dog" in word_set! In front_visited? NO → add             │
  │      → "log" in word_set! In front_visited? NO → add             │
  │    Change pos 1: cag,cbg,...,czg → none in word_set               │
  │    Change pos 2: coa,cob,...,coz → none in word_set               │
  │                                                                    │
  │  back_set = {"dog", "log"}                                        │
  │  back_visited = {"cog", "dog", "log"}                              │
  │  depth = 3                                                         │
  │                                                                    │
  │  Visual:                                                           │
  │                                                                    │
  │    hit ── hot ─ ─ ─ ─ ─ ─ dog ── cog                             │
  │           F→              log ──┘                                  │
  │                            ←B                                     │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │  ITERATION 3:                                                      │
  │                                                                    │
  │  |front_set| = 1 ("hot"), |back_set| = 2 ("dog","log")           │
  │  front is SMALLER → expand front                                  │
  │                                                                    │
  │  Expand "hot":                                                     │
  │    Change pos 0: aot,bot,...,dot,...,lot,...,zot                   │
  │      → "dot" in word_set! In back_visited? NO → add to front     │
  │      → "lot" in word_set! In back_visited? NO → add to front     │
  │    Change pos 1: hat,hbt,...,hzt → none new                       │
  │    Change pos 2: hoa,hob,...,hoz → none in word_set               │
  │                                                                    │
  │  front_set = {"dot", "lot"}                                        │
  │  front_visited = {"hit", "hot", "dot", "lot"}                     │
  │  depth = 4                                                         │
  │                                                                    │
  │  Visual:                                                           │
  │                                                                    │
  │    hit ── hot ── dot ─ ─ dog ── cog                               │
  │                  lot ─ ─ log ──┘                                   │
  │                   F→      ←B                                      │
  │           Frontiers getting closer!                                │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │  ITERATION 4:                                                      │
  │                                                                    │
  │  |front_set| = 2 ("dot","lot"), |back_set| = 2 ("dog","log")     │
  │  Same size → expand either (let's do back)                        │
  │                                                                    │
  │  Expand "dog":                                                     │
  │    Change pos 0: aog,bog,...,log (already visited back),...        │
  │    Change pos 1: dag,dbg,...,dzg → none                           │
  │    Change pos 2: doa,dob,...,dot,...,doz                           │
  │      → "dot" in word_set! In front_visited?                       │
  │        front_visited = {"hit","hot","dot","lot"}                  │
  │        YES! "dot" IS in front_visited!                            │
  │                                                                    │
  │  ══════════════════════════════════════════════════════════════    │
  │  PATHS MEET AT "dot"!                                              │
  │                                                                    │
  │  Return depth = 5                                                  │
  │  ══════════════════════════════════════════════════════════════    │
  │                                                                    │
  │  Full path: hit → hot → dot → dog → cog                          │
  │             ←── front ──→←── back ──→                             │
  │                                                                    │
  │  Verification: 5 words, 4 steps ✓                                │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Counting Nodes Explored</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  STANDARD BFS (from Problem 15):                                   │
  │    Level 0: hit          (1 node)                                  │
  │    Level 1: hot          (1 node)                                  │
  │    Level 2: dot, lot     (2 nodes)                                 │
  │    Level 3: dog, log     (2 nodes)                                 │
  │    Level 4: cog          (1 node)  ← found!                       │
  │    Total explored: 7 nodes                                         │
  │                                                                    │
  │  BIDIRECTIONAL BFS:                                                │
  │    Front: hit → hot → {dot,lot}     (4 nodes from front)          │
  │    Back:  cog → {dog,log} → dot!    (3 nodes from back)           │
  │    Total explored: 7 nodes                                         │
  │                                                                    │
  │  Same here because graph is small!                                 │
  │  The difference shows on LARGE graphs with high branching factor.  │
  │                                                                    │
  │  If branching factor b=100 and depth d=10:                         │
  │    Standard: 100^10 = 10^20 nodes                                  │
  │    Bidirectional: 2 × 100^5 = 2 × 10^10 nodes                    │
  │    SPEEDUP: 5 × 10^9 ×                                            │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 5: COMPLETE CODE</h2>
<h3>Solution 1: Bidirectional BFS for Word Ladder</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">ladder_length_bidirectional</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Word Ladder using Bidirectional BFS.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Key differences from standard BFS (Problem 15):
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → TWO frontiers: one from start, one from goal
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Always expand the SMALLER frontier (optimization)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → When frontiers OVERLAP → path found
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Total depth = sum of both sides' depths
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Why faster:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Standard BFS: explores b^d nodes
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Bidirectional:  explores 2 × b^(d/2) nodes
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Exponential speedup when b is large
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    REQUIREMENT: must know both START and GOAL
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    (if goal is unknown, can't search backwards from it)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Args:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        begin_word: starting word
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        end_word: target word
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        word_list: list of valid words
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Returns:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Length of shortest transformation sequence, or 0 if impossible.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    word_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Edge case: end_word must be in dictionary</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> end_word </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Initialize TWO frontiers ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Using SETS for O(1) membership testing</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># BFS frontier from start</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>       </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># BFS frontier from goal</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Track visited from each side separately</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Need separate sets to detect when frontiers MEET</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># begin_word counts as step 1</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── OPTIMIZATION: Always expand the SMALLER frontier ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># This keeps both sides balanced</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># If front is larger, swap so we always expand "front"</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Expand the smaller frontier by one level ───</span><span>
</span><span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Try changing each position to each letter</span><span>
</span><span>            word_list_chars </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                original_char </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> word_list_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> c </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'abcdefghijklmnopqrstuvwxyz'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> original_char</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span>                    
<span>                    word_list_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> c
</span><span>                    new_word </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">''</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>join</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                    
<span>                    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── CHECK: Does this word meet the OTHER frontier? ───</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Frontiers overlap!</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Current depth from this side + 1 (for new_word)</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># But new_word is already counted in back side</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>                    
<span>                    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Add to frontier if valid and unvisited ───</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>new_word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>new_word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                word_list_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> original_char  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># restore</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Move to next level</span><span>
</span><span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># One frontier exhausted → no path</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── TEST CASES ───</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test 1: Standard example</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Test 1: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ladder_length_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'cog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'lot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'log'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'cog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 5</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test 2: No path</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Test 2: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ladder_length_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'cog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'lot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'log'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 0 (cog not in word list)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test 3: Direct neighbor</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Test 3: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ladder_length_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 2 (hot → dot)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test 4: Same word</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Test 4: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ladder_length_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 1 (already there)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test 5: Longer chain</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Test 5: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ladder_length_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'sand'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'acne'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'sand'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'sane'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'acne'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 3 (sand → sane → acne)</span></code></pre></div>
<hr>
<h3>Solution 2: Generic Bidirectional BFS Template</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">bidirectional_bfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    GENERIC Bidirectional BFS template.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Works for ANY problem where:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Graph is unweighted (each step costs 1)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Both START and GOAL are known
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → get_neighbors(state) returns list of neighboring states
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This template can be applied to:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Word ladder (this problem)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Sliding puzzle (15-puzzle)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Rubik's cube solving
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Any state-space search with known start and goal
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Args:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        start: starting state (must be hashable)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        goal: target state (must be hashable)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        get_neighbors: function(state) → list of neighbor states
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Returns:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Shortest distance from start to goal, or -1 if unreachable.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> start </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Two frontiers</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>goal</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Two visited sets</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>goal</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Always expand the SMALLER frontier</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> state </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>state</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Check if frontiers meet</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth
</span>                
<span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># unreachable</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Apply to Word Ladder ───</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">word_ladder_bidir</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    word_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> end_word </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Generate all words one letter different that exist in word_set."""</span><span>
</span><span>        neighbors </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        word_chars </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            orig </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> c </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'abcdefghijklmnopqrstuvwxyz'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> orig</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> c
</span><span>                    candidate </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">''</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>join</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> candidate </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        neighbors</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>candidate</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> orig
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> neighbors
</span>    
<span>    result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> bidirectional_bfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Word ladder counts words (not steps), so add 1</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> result </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> result </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">else</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Template: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">word_ladder_bidir</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hit'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'cog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'hot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'dog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'lot'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'log'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'cog'</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 5</span></code></pre></div>
<hr>
<h3>Solution 3: Bidirectional BFS for Graph Shortest Path</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> deque
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">shortest_path_bidirectional</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> source</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Bidirectional BFS on an explicit graph (adjacency list).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    For comparison with standard BFS (Problem 9):
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Same correctness (finds shortest path)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Better performance on large, high-branching graphs
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    NOTE: Graph must be UNDIRECTED (or we need reverse graph for back search).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    For directed graphs, we need to build a REVERSE adjacency list
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    for the backward search.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Build adjacency list (undirected)</span><span>
</span><span>    graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> source </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Two BFS frontiers</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>source</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>target</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>source</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>target</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Expand smaller frontier</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test on a graph</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   0 - 1 - 2 - 3 - 4 - 5</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Graph bidir: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">shortest_path_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> edges</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">0</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">5</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 5</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test with branching</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   0 - 1 - 3 - 5</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   0 - 2 - 4 - 5</span><span>
</span><span>edges2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Graph bidir 2: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">shortest_path_bidirectional</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">6</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> edges2</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">0</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">5</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 3</span></code></pre></div>
<hr>
<h3>Handling Directed Graphs: Reverse Graph Needed</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">shortest_path_bidir_directed</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> source</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Bidirectional BFS on a DIRECTED graph.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    KEY DIFFERENCE: backward search needs the REVERSE graph!
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Forward search: follows edges u → v (normal direction)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Backward search: follows edges v → u (REVERSE direction)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Must build TWO adjacency lists:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → forward_graph[u] = [v, ...]  (normal edges)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → reverse_graph[v] = [u, ...]  (reversed edges)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Build BOTH forward and reverse graphs</span><span>
</span><span>    forward_graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    reverse_graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        forward_graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        reverse_graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># reverse edge</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> source </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Forward BFS uses forward_graph</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Backward BFS uses reverse_graph</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>source</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>target</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>source</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>target</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Track which graph each side uses</span><span>
</span><span>    front_graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> forward_graph
</span><span>    back_graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> reverse_graph
</span>    
<span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Expand smaller frontier</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span><span>            front_graph</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_graph </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_graph</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_graph
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_graph</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test: directed graph</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 0 → 1 → 2 → 3 → 4</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Directed bidir: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">shortest_path_bidir_directed</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">5</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> edges</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">0</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">4</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 4</span></code></pre></div>
<hr>
<h2>STEP 6: COMPLEXITY ANALYSIS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────────┐
</span>  │  Let b = branching factor, d = shortest path distance           │
  │      V = vertices, E = edges                                    │
  │                                                                  │
  │  STANDARD BFS:                                                   │
  │    Time:  O(b^d)  or  O(V + E) in graph terms                  │
  │    Space: O(b^d)  (frontier + visited)                          │
  │                                                                  │
  │  BIDIRECTIONAL BFS:                                              │
  │    Time:  O(b^(d/2))  or  O(V + E) worst case                  │
  │    Space: O(b^(d/2))  (two frontiers + two visited sets)        │
  │                                                                  │
  │  NOTE: In graph-theory terms (V, E), both are O(V + E)         │
  │  worst case. The difference is in PRACTICE:                      │
  │    → Standard BFS may explore MANY more nodes before reaching   │
  │      the goal                                                    │
  │    → Bidirectional BFS typically explores far fewer              │
  │    → The improvement is in the CONSTANT factor hidden in O()    │
  │    → For state-space search (word ladder, puzzles), the         │
  │      difference is DRAMATIC                                     │
  │                                                                  │
  ├──────────────────────────────────────────────────────────────────┤
  │                                                                  │
  │  FOR WORD LADDER SPECIFICALLY:                                   │
  │    Let L = word length, W = word list size                      │
  │                                                                  │
  │    Neighbor generation per word: O(26 × L) = O(L)               │
  │    Standard BFS: O(W × L) in worst case (visit all words)       │
  │    Bidirectional: O(√W × L) in typical case                     │
  │      (each side explores ≈ √W words if branching is uniform)    │
  │                                                                  │
  │  SPACE for both: O(W) for visited sets                          │
  │                                                                  │
  └──────────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Why "Always Expand Smaller Frontier"?</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  WITHOUT balancing (always expand front):                          │
  │                                                                    │
  │    Front: 1 → 10 → 100 → 1000 → ...                              │
  │    Back:  1 (never expanded until front reaches it)                │
  │    → Same as standard BFS! No benefit.                            │
  │                                                                    │
  │  WITH balancing (expand smaller side):                             │
  │                                                                    │
  │    Front: 1 → 10                                                   │
  │    Back:  1 → 10    (expanded because |back|=1 &lt; |front|=10)     │
  │    Front: 10 → 100  (expanded because |front|=10 = |back|=10)    │
  │    Back:  10 → 100                                                │
  │    → Both sides grow equally → meet at depth d/2                  │
  │    → Total: 2 × b^(d/2) ← OPTIMAL                               │
  │                                                                    │
  │  INTUITION:                                                        │
  │    If one side has 10 nodes and other has 1000,                    │
  │    expanding the 1000 side creates ~10,000 new nodes.             │
  │    Expanding the 10 side creates ~100 new nodes.                   │
  │    MUCH cheaper to expand the small side!                          │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 7: THE SWAP TRICK — DEEP DIVE</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  The most elegant part of bidirectional BFS is the SWAP:
</span>
  if len(front_set) &gt; len(back_set):
      front_set, back_set = back_set, front_set
      front_visited, back_visited = back_visited, front_visited

  WHAT THIS DOES:
    → "I always expand front_set"
    → "If front is bigger, MAKE IT the back (by swapping)"
    → "Now I'm expanding what was previously the back"
    → "Same logic, no code duplication!"

  WITHOUT SWAP (ugly version):
    if len(front_set) &lt;= len(back_set):
        # expand front_set...
        # check against back_visited...
        # update front_set, front_visited...
    else:
        # expand back_set...
        # check against front_visited...
        # update back_set, back_visited...
    
    → DUPLICATED CODE! Same logic twice!

  WITH SWAP (clean version):
    # Swap so front is always smaller
    if len(front_set) &gt; len(back_set):
        swap all front/back variables
    
    # Now just expand front_set (which is the smaller one)
    # Check against back_visited (which is the other side)
    
    → SINGLE code path! Clean and correct!

  THIS IS A COMMON INTERVIEW TRICK:
    → "I'll always process the smaller set"
    → "I just swap labels if needed"
    → Shows clean thinking and avoids code duplication</code></pre></div>
<hr>
<h2>STEP 8: WHEN BIDIRECTIONAL BFS DOESN'T WORK</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════════╗
</span>  ║  REQUIREMENT 1: Must know the GOAL state                        ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  ✓ Word Ladder: know both beginWord and endWord                 ║
  ║  ✓ Sliding puzzle: know both start and goal configuration       ║
  ║  ✗ "Find nearest hospital": don't know which hospital is closest║
  ║  ✗ "Find any node with property X": goal is unknown             ║
  ║                                                                  ║
  ║  For unknown goals: use standard BFS or multi-source BFS        ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  REQUIREMENT 2: Must be able to search BACKWARDS                ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  For UNDIRECTED graphs: backward = forward (no issue)            ║
  ║  For DIRECTED graphs: need REVERSE graph for backward search    ║
  ║                                                                  ║
  ║  If reverse graph is hard to build or edges are one-way:         ║
  ║    → Bidirectional BFS is possible but needs extra work          ║
  ║    → Must precompute reverse adjacency list                      ║
  ║                                                                  ║
  ║  For IMPLICIT graphs (word ladder, puzzles):                     ║
  ║    → Backward neighbors = same as forward neighbors              ║
  ║      (changing one letter works both ways)                       ║
  ║    → No issue!                                                   ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  REQUIREMENT 3: Unweighted graph (or all edges same weight)     ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  BFS works for unweighted shortest path.                        ║
  ║  Bidirectional BFS inherits this requirement.                    ║
  ║                                                                  ║
  ║  For WEIGHTED graphs:                                            ║
  ║    → Bidirectional Dijkstra exists but is MORE COMPLEX           ║
  ║    → Meeting point doesn't guarantee shortest path directly     ║
  ║    → Need additional checks (more advanced topic)                ║
  ║    → A* search (Problem 48) is usually preferred for weighted   ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  WHEN IT DOESN'T HELP MUCH:                                     ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  → Low branching factor (b ≈ 1-2): not much to save             ║
  ║    Standard BFS: b^d ≈ 2^d                                      ║
  ║    Bidirectional:  2 × 2^(d/2) = 2^(d/2 + 1)                   ║
  ║    Savings: 2^(d/2 - 1) — still good but less dramatic          ║
  ║                                                                  ║
  ║  → Very short paths (d ≤ 3): overhead of two frontiers          ║
  ║    may not be worth it                                           ║
  ║                                                                  ║
  ║  → Tree-like graphs (no alternative paths):                      ║
  ║    Only one path exists → both sides find it at same speed       ║
  ║                                                                  ║
  ║  BEST FOR:                                                       ║
  ║  → HIGH branching factor + LONG path                             ║
  ║  → Dense graphs with many alternative paths                      ║
  ║  → State-space search (puzzles, word games)                      ║
  ╚══════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 9: APPLICATION — SLIDING PUZZLE (BONUS)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">sliding_puzzle</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>board</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LeetCode 773: Sliding Puzzle
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Given a 2×3 board with tiles 1-5 and one empty space (0),
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    find minimum moves to reach the goal state:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      [[1,2,3],
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">       [4,5,0]]
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is a CLASSIC bidirectional BFS problem:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → State = board configuration (tuple for hashability)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Neighbors = swap 0 with adjacent tile
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      → Know BOTH start and goal → bidirectional!
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    State space: 6! = 720 possible configurations
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    → Small enough for standard BFS too
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    → But demonstrates the bidirectional pattern
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Encode board as tuple for hashing</span><span>
</span><span>    start </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">tuple</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>board</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> board</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    goal </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> start </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> goal</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Neighbor positions for each index in the flattened 2×3 board</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Index: 0 1 2</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#        3 4 5</span><span>
</span><span>    neighbors_map </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>state</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Generate all states reachable by one slide."""</span><span>
</span><span>        state_list </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>state</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        zero_idx </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> state_list</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>index</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> swap_idx </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> neighbors_map</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>zero_idx</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            new_state </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> state_list</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            new_state</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>zero_idx</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> new_state</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>swap_idx</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> \
</span><span>                new_state</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>swap_idx</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> new_state</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>zero_idx</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            result</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">tuple</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>new_state</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> result
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Bidirectional BFS</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>goal</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>start</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>goal</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span>    
<span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> state </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> get_neighbors</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>state</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span>board1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Sliding puzzle 1: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">sliding_puzzle</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">board1</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 1 (swap 0 and 5)</span><span>
</span>
<span>board2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Sliding puzzle 2: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">sliding_puzzle</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">board2</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: 5</span><span>
</span>
<span>board3 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Sliding puzzle 3: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">sliding_puzzle</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">board3</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Output: -1 (impossible configuration)</span></code></pre></div>
<hr>
<h2>STEP 10: CORRECTNESS PROOF — WHY MEETING = SHORTEST PATH</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  CLAIM: When bidirectional BFS frontiers meet,                     │
  │         the total depth = shortest path distance.                  │
  │                                                                    │
  │  PROOF:                                                            │
  │                                                                    │
  │  Let d = shortest path distance from start to goal.               │
  │  Let the shortest path be: start = v0, v1, v2, ..., vd = goal.   │
  │                                                                    │
  │  At any point in bidirectional BFS:                                │
  │    front_depth + back_depth = current total depth                  │
  │    (where front_depth = levels explored from start,                │
  │     back_depth = levels explored from goal)                        │
  │                                                                    │
  │  The algorithm stops when front_depth + back_depth = d.            │
  │                                                                    │
  │  WHY?                                                              │
  │  → Front BFS has explored all nodes within distance front_depth   │
  │    from start                                                      │
  │  → Back BFS has explored all nodes within distance back_depth     │
  │    from goal                                                       │
  │  → On the shortest path, node v_{front_depth} is in front_visited│
  │    and v_{d - back_depth} is in back_visited                      │
  │  → When front_depth + back_depth = d:                             │
  │    v_{front_depth} and v_{d - back_depth} are adjacent            │
  │    OR the same node                                                │
  │  → Expanding one more level detects this overlap                  │
  │                                                                    │
  │  Can we find a SHORTER path?                                       │
  │  → No! If path of length &lt; d existed, the frontiers would have   │
  │    met EARLIER (at a smaller total depth)                         │
  │  → BFS explores ALL nodes at distance k before distance k+1      │
  │  → First meeting = shortest distance ✓                            │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 11: COMMON PITFALLS AND EDGE CASES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════════╗
</span>  ║  PITFALL 1: Checking overlap BEFORE generating neighbors         ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  WRONG:                                                          ║
  ║    for word in front_set:                                        ║
  ║        if word in back_visited:  ← checking CURRENT frontier     ║
  ║            return depth                                          ║
  ║                                                                  ║
  ║  This checks if the EXISTING frontier overlaps, but we need     ║
  ║  to check if the NEW NEIGHBORS overlap with the other side.     ║
  ║                                                                  ║
  ║  RIGHT:                                                          ║
  ║    for word in front_set:                                        ║
  ║        for neighbor in get_neighbors(word):                      ║
  ║            if neighbor in back_visited:  ← checking NEIGHBORS    ║
  ║                return depth + 1 (or depth, depending on counting)║
  ║                                                                  ║
  ║  Actually, the initial check CAN work if done at the start      ║
  ║  of each iteration (before expanding), but counting must         ║
  ║  be adjusted carefully.                                          ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 2: Off-by-one in depth counting                         ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  The trickiest part of bidirectional BFS!                        ║
  ║                                                                  ║
  ║  front_depth = number of levels expanded from front              ║
  ║  back_depth = number of levels expanded from back                ║
  ║  total_distance = front_depth + back_depth                       ║
  ║                                                                  ║
  ║  When we detect overlap while expanding front at depth d:        ║
  ║    → The new neighbor is at depth d from front                   ║
  ║    → It's already in back_visited at some depth from back        ║
  ║    → Total = d (current depth counter)                           ║
  ║                                                                  ║
  ║  CAREFUL: the depth variable tracks differently depending on     ║
  ║  when you increment it and how you count.                        ║
  ║                                                                  ║
  ║  SAFEST: trace through a small example to verify counting        ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 3: Not handling start == goal                           ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  If start == goal: return 0 immediately                          ║
  ║  Without this check: both sets start as {same_node}              ║
  ║  → Immediate overlap detection might return wrong depth          ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  PITFALL 4: Forgetting to swap visited sets along with frontiers ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  WRONG (incomplete swap):                                        ║
  ║    front_set, back_set = back_set, front_set                     ║
  ║    # forgot to swap visited sets!                                ║
  ║                                                                  ║
  ║  RIGHT (complete swap):                                          ║
  ║    front_set, back_set = back_set, front_set                     ║
  ║    front_visited, back_visited = back_visited, front_visited     ║
  ║                                                                  ║
  ║  If using directed graphs, also swap the graph references!       ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: No path exists                                       ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  One frontier becomes empty (no more neighbors to explore)       ║
  ║  → While loop exits → return -1 or 0                            ║
  ║                                                                  ║
  ║  Both standard and bidirectional BFS handle this correctly:      ║
  ║  if the graph is disconnected and start/goal are in different    ║
  ║  components, one frontier will exhaust before meeting the other. ║
  ╚══════════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Goal not in word list                                ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  For word ladder: if endWord not in wordList, return 0           ║
  ║  Check this BEFORE starting BFS                                  ║
  ║  (backward search can't start from a non-existent word)          ║
  ╚══════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 12: CONNECTION TO PREVIOUS PROBLEMS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Problem 3  → BFS (the foundation — bidirectional BFS = two BFS's)
</span>  Problem 9  → BFS shortest path (bidirectional BFS optimizes this)
  Problem 13 → Multi-source BFS (multiple start points — related concept)
  Problem 15 → Word Ladder (the SAME problem, now with optimization)
  Problem 38 → State-space BFS (can combine: bidirectional + state-space)
  Problem 39 → 0-1 BFS (different optimization for different problem)
  Problem 40 → Dijkstra on grid (weighted — bidir Dijkstra is possible 
               but much more complex)

  EVOLUTION OF BFS OPTIMIZATIONS:

  ┌──────────────────────────────────────────────────────────────────────┐
  │  Problem │  Optimization              │  When It Helps              │
  ├──────────┼────────────────────────────┼─────────────────────────────┤
  │  3,9     │  None (standard BFS)       │  Baseline                   │
  │  13      │  Multi-source (many starts)│  Need distance from NEAREST │
  │          │                            │  of many sources            │
  │  39      │  0-1 BFS (deque)           │  Weights are {0,1}         │
  │  42      │  Bidirectional (two BFS's) │  Know both start AND goal, │
  │  (THIS)  │                            │  high branching factor      │
  │  48      │  A* (heuristic guidance)   │  Know goal, have good      │
  │  (future)│                            │  distance estimate          │
  └──────────┴────────────────────────────┴─────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 13: BIDIRECTIONAL BFS VS A* (PREVIEW OF PROBLEM 48)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  BIDIRECTIONAL BFS:                                                │
  │    → Search from BOTH ends                                         │
  │    → No domain knowledge needed                                    │
  │    → Works for ANY unweighted graph                                │
  │    → Speedup: b^d → 2 × b^(d/2)                                  │
  │    → "Explore less by meeting in the middle"                       │
  │                                                                    │
  │  A* SEARCH (Problem 48):                                           │
  │    → Search from ONE end with a HEURISTIC                          │
  │    → Needs domain-specific distance estimate                       │
  │    → Works for weighted graphs too                                 │
  │    → Speedup depends on heuristic quality                          │
  │    → "Explore less by going in the RIGHT DIRECTION"                │
  │                                                                    │
  │  COMBINED: Bidirectional A*                                        │
  │    → Both optimizations at once                                    │
  │    → Complex to implement correctly                                │
  │    → Used in real navigation systems (Google Maps, etc.)           │
  │                                                                    │
  │  WHEN TO CHOOSE:                                                   │
  │    → No heuristic available → Bidirectional BFS                    │
  │    → Good heuristic available → A*                                 │
  │    → Both available → Bidirectional A* (advanced)                  │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 14: WHEN TO USE THIS VS ALTERNATIVES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  "Shortest path, unweighted, know start and goal"                  │
  │                                                                    │
  │    Small graph (V &lt; 10^4):                                         │
  │      → Standard BFS (Problem 9) — simpler, fast enough            │
  │                                                                    │
  │    Large graph, high branching:                                    │
  │      → Bidirectional BFS (THIS) — exponential speedup             │
  │                                                                    │
  │    Large graph, have distance heuristic:                           │
  │      → A* search (Problem 48) — guided search                     │
  │                                                                    │
  │  "Shortest path, unweighted, DON'T know goal"                     │
  │    → Standard BFS only (can't search backward from unknown goal)  │
  │                                                                    │
  │  "Shortest path, WEIGHTED, know start and goal"                    │
  │    → Dijkstra (Problem 23) — bidirectional Dijkstra is complex    │
  │    → A* with heuristic (Problem 48) — usually preferred           │
  │                                                                    │
  │  "Shortest path from MULTIPLE sources"                             │
  │    → Multi-source BFS (Problem 13)                                 │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 15: HOW I WOULD RECOGNIZE THIS PATTERN IN AN INTERVIEW</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  SIGNAL 1: "Shortest path" + "both start and end are known"       │
  │    → Candidate for bidirectional BFS                               │
  │                                                                    │
  │  SIGNAL 2: "BFS is too slow" / "TLE on large inputs"             │
  │    → Need BFS optimization                                        │
  │    → If know both ends → bidirectional                             │
  │    → If weights are {0,1} → 0-1 BFS (Problem 39)                 │
  │    → If have heuristic → A* (Problem 48)                          │
  │                                                                    │
  │  SIGNAL 3: "Large state space with high branching factor"          │
  │    → Word transformations (26 choices per position)                │
  │    → Puzzle states (many possible moves)                           │
  │    → Combinatorial explosion                                       │
  │    → Bidirectional cuts exploration exponentially                   │
  │                                                                    │
  │  SIGNAL 4: Problem explicitly mentions both START and END states   │
  │    → "Transform X into Y in minimum steps"                         │
  │    → "Minimum moves from configuration A to configuration B"       │
  │                                                                    │
  │  MY THOUGHT PROCESS:                                               │
  │                                                                    │
  │    "Shortest transformation from beginWord to endWord"             │
  │      → Unweighted shortest path → BFS                             │
  │                                                                    │
  │    "Word list is huge, might TLE"                                  │
  │      → Need optimization                                          │
  │                                                                    │
  │    "I know both start AND end"                                     │
  │      → Bidirectional BFS!                                          │
  │      → Search from both sides                                      │
  │      → Meet in the middle                                          │
  │      → Always expand smaller frontier                              │
  │      → O(b^(d/2)) instead of O(b^d)                                │
  │                                                                    │
  │  INTERVIEW SCRIPT:                                                 │
  │                                                                    │
  │    Step 1: "This is a shortest path problem in unweighted graph"   │
  │    Step 2: "Standard BFS would work but might be slow for large    │
  │             inputs because the search space grows as b^d"          │
  │    Step 3: "Since we know both start and end, I can use            │
  │             bidirectional BFS to reduce exploration to b^(d/2)"    │
  │    Step 4: "The trick is to always expand the smaller frontier     │
  │             to keep both sides balanced"                            │
  │    Step 5: "When frontiers overlap, we've found the shortest path" │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 16: THE "MEET IN THE MIDDLE" PARADIGM</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║  Bidirectional BFS is an instance of a GENERAL paradigm:           ║
  ║  "MEET IN THE MIDDLE"                                              ║
  ║                                                                    ║
  ║  The idea: split a problem into TWO HALVES,                        ║
  ║  solve each half independently, then COMBINE results.              ║
  ║                                                                    ║
  ║  WHERE THIS PARADIGM APPEARS:                                      ║
  ║                                                                    ║
  ║  ┌──────────────────────┬───────────────────────────────────────┐  ║
  ║  │  Application          │  How "Meet in Middle" Applies        │  ║
  ║  ├──────────────────────┼───────────────────────────────────────┤  ║
  ║  │  Bidirectional BFS    │  Search from both ends,              │  ║
  ║  │  (THIS problem)       │  meet when frontiers overlap         │  ║
  ║  ├──────────────────────┼───────────────────────────────────────┤  ║
  ║  │  Subset Sum           │  Split items into two halves,        │  ║
  ║  │  (competitive prog)   │  enumerate sums of each half,        │  ║
  ║  │                       │  find complementary pairs            │  ║
  ║  │                       │  O(2^n) → O(2^(n/2))               │  ║
  ║  ├──────────────────────┼───────────────────────────────────────┤  ║
  ║  │  4-Sum problem        │  Split into pairs, enumerate         │  ║
  ║  │                       │  all pair sums, find complement      │  ║
  ║  │                       │  O(n^4) → O(n^2 log n)             │  ║
  ║  ├──────────────────────┼───────────────────────────────────────┤  ║
  ║  │  Baby-step Giant-step │  Discrete logarithm algorithm        │  ║
  ║  │  (number theory)      │  O(n) → O(√n)                      │  ║
  ║  └──────────────────────┴───────────────────────────────────────┘  ║
  ║                                                                    ║
  ║  COMMON THEME:                                                     ║
  ║    Exponential problem of size d → two problems of size d/2        ║
  ║    b^d → 2 × b^(d/2)                                             ║
  ║    SQUARE ROOT of original complexity!                              ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 17: COMPLETE COMPARISON — ALL BFS VARIANTS (Problems 3 → 42)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                        ║
  ║  THE COMPLETE BFS FAMILY                                               ║
  ║                                                                        ║
  ║  Problem │ Variant            │ Data Structure │ Key Innovation        ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  3       │ Basic BFS          │ Queue          │ Level-by-level        ║
  ║          │                    │                │ exploration           ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  9       │ Shortest path BFS  │ Queue          │ BFS = shortest        ║
  ║          │                    │                │ when weights equal    ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  13      │ Multi-source BFS   │ Queue          │ Multiple start        ║
  ║          │                    │                │ points simultaneously ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  15      │ Implicit graph BFS │ Queue          │ Build graph during    ║
  ║          │                    │                │ search (word ladder)  ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  38      │ State-space BFS    │ Queue          │ State = (pos, extra)  ║
  ║          │                    │                │ keys, fuel, etc.      ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  39      │ 0-1 BFS            │ Deque          │ Weights {0,1}        ║
  ║          │                    │                │ front/back insertion  ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║  42      │ Bidirectional BFS  │ Two sets       │ Search from both     ║
  ║  (THIS)  │                    │                │ ends, meet middle    ║
  ║  ────────┼────────────────────┼────────────────┼──────────────────     ║
  ║                                                                        ║
  ║  COMPOSABILITY — These techniques can COMBINE:                         ║
  ║                                                                        ║
  ║  → Bidirectional + State-space: search from both ends with             ║
  ║    expanded state (keys, etc.)                                         ║
  ║  → Multi-source + 0-1 BFS: multiple sources with {0,1} weights       ║
  ║  → Bidirectional + Implicit: word ladder with bidirectional search     ║
  ║  → State-space + 0-1 BFS: keys/locks with free/costly moves          ║
  ║                                                                        ║
  ║  Each variant is a BUILDING BLOCK. Master each independently,          ║
  ║  then combine as needed.                                               ║
  ║                                                                        ║
  ╚════════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 18: VERSION WITH DEBUG OUTPUT</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">ladder_length_bidir_debug</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> end_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Bidirectional BFS with detailed trace output.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    word_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> end_word </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  End word '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">end_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">' not in word list → impossible"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\n</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'='</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">*</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">60</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Bidirectional BFS: '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">begin_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">' → '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">end_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">'"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Word list: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">word_list</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'='</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">*</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">60</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\nInit: front=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">front_set</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, back=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">back_set</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, depth=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">depth</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    iteration </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        iteration </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Swap to expand smaller</span><span>
</span><span>        swapped </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">False</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span><span>            swapped </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span>        
<span>        expanding </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">"front"</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> swapped </span><span class="token" style="color: rgb(0, 0, 255);">else</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">"back (swapped to front)"</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\n--- Iteration </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">iteration</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);"> ---"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  |front|=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation builtin">len</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">front_set</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, |back|=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation builtin">len</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">back_set</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  Expanding: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">expanding</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  Frontier: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">front_set</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            word_chars </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                orig </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> c </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'abcdefghijklmnopqrstuvwxyz'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> orig</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">continue</span><span>
</span><span>                    word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> c
</span><span>                    new_word </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">''</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>join</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                    
<span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\n  ★ MEET! '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">' → '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">new_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">' found in other side!"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  ★ Answer = depth + 1 = </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">depth </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">+</span><span class="token string-interpolation interpolation"> </span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">1</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>                    
<span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> new_word </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>new_word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                        front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>new_word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> orig
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"  New frontier: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">next_front</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span><span>        depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\n  ✗ Frontier exhausted. No path exists."</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Run with debug</span><span>
</span><span>ladder_length_bidir_debug</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'hit'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'cog'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(163, 21, 21);">'hot'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'dot'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'dog'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'lot'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'log'</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">'cog'</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<p><strong>Debug Output:</strong></p>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>============================================================
</span>Bidirectional BFS: 'hit' → 'cog'
Word list: ['hot', 'dot', 'dog', 'lot', 'log', 'cog']
============================================================

Init: front={'hit'}, back={'cog'}, depth=1

--- Iteration 1 ---
  |front|=1, |back|=1
  Expanding: front
  Frontier: {'hit'}
  New frontier: {'hot'}

--- Iteration 2 ---
  |front|=1, |back|=1
  Expanding: front
  Frontier: {'hot'}
  New frontier: {'lot', 'dot'}

--- Iteration 3 ---
  |front|=1, |back|=2
  Expanding: back (swapped to front)
  Frontier: {'cog'}
  New frontier: {'log', 'dog'}

--- Iteration 4 ---
  |front|=2, |back|=2
  Expanding: front
  Frontier: {'lot', 'dot'}

  ★ MEET! 'dot' → 'dog' found in other side!
  ★ Answer = depth + 1 = 5</code></pre></div>
<hr>
<h2>STEP 19: BIDIRECTIONAL BFS ON LARGER EXAMPLE</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">performance_comparison</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Compare standard BFS vs bidirectional BFS on a larger word ladder.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Count nodes explored by each approach.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Build a larger word list</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># All 3-letter words from a small vocabulary</span><span>
</span><span>    word_list </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"hot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"log"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"cog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"hog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"hit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"hat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"cat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"cot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"cog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"cop"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"cap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"car"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bar"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"big"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"box"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fox"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fix"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"fig"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fin"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fun"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fan"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"far"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"for"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fog"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"foe"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"fee"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"bee"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bet"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bed"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bid"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bin"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bun"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"but"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bus"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"bud"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"bug"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dug"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dig"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dim"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"dip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lid"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"lad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"lap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"map"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"mat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"mad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"man"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"men"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"met"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"net"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"new"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"now"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"not"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nor"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nod"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nob"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nil"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"nap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"nag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"oar"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"oat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"odd"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"old"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"one"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ore"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"our"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"out"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"own"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pal"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pan"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pay"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pea"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pen"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"pet"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pie"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pig"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pin"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pod"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pop"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pub"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"pun"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"pup"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"put"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ram"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ran"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"raw"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"ray"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"red"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rib"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rid"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rig"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rim"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rob"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rod"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"rot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"row"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rub"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rug"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rum"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"run"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"rut"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"sap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"saw"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"say"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sea"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"set"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sew"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"shy"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sin"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"sip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sir"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sis"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"six"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ski"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sky"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sly"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sob"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"sod"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"son"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sop"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sow"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"soy"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"spa"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"spy"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sty"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"sub"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sue"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sum"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sun"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"sup"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tab"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tan"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"tap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tar"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tax"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tea"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ten"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"the"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tie"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tin"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"tip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"toe"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"ton"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"too"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"top"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tot"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tow"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"toy"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"try"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"tub"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"tug"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"two"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"van"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"vat"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"vet"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"via"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"vie"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"vow"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"wad"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wag"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"war"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"was"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wax"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"way"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"web"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wed"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wet"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"who"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"why"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wig"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"win"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wit"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"woe"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"wok"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"won"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"woo"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"wow"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yak"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yam"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yaw"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yea"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yes"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yet"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"yew"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span>
</span><span>        </span><span class="token" style="color: rgb(163, 21, 21);">"you"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"zap"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"zip"</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(163, 21, 21);">"zoo"</span><span>
</span><span>    </span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    begin_word </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">"hit"</span><span>
</span><span>    end_word </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">"boy"</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># not in list, let's use a reachable one</span><span>
</span><span>    end_word </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">"fan"</span><span>
</span>    
<span>    word_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">get_neighbors_counted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> counter</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        neighbors </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        word_chars </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> i </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            orig </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> c </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">'abcdefghijklmnopqrstuvwxyz'</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> c </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> orig</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> c
</span><span>                    candidate </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(163, 21, 21);">''</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>join</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word_chars</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> candidate </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> word_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                        neighbors</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>candidate</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            word_chars</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>i</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> orig
</span><span>        counter</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># count nodes expanded</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> neighbors
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Standard BFS</span><span>
</span><span>    counter_standard </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    standard_result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> get_neighbors_counted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> counter_standard</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> end_word</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                standard_result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>clear</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Bidirectional BFS</span><span>
</span><span>    counter_bidir </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    front_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>begin_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">{</span><span>end_word</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span>
</span><span>    bidir_depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>    bidir_result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> front_set </span><span class="token" style="color: rgb(0, 0, 255);">and</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>front_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>back_set</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            front_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_set</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_set
</span><span>            front_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> back_visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> front_visited
</span>        
<span>        next_front </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        found </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">False</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> word </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_set</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> get_neighbors_counted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>word</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> counter_bidir</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> back_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    bidir_result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> bidir_depth </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span><span>                    found </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                    </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> front_visited</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    next_front</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                    front_visited</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>add</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> found</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> found</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">break</span><span>
</span>        
<span>        front_set </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> next_front
</span><span>        bidir_depth </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"\n</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'='</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">*</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">50</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Word Ladder: '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">begin_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">' → '</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">end_word</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">'"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Word list size: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation builtin">len</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">word_list</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation" style="color: rgb(163, 21, 21);">'='</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">*</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">50</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Standard BFS:      result=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">standard_result</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, nodes expanded=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">counter_standard</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">0</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Bidirectional BFS:  result=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">bidir_result</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">, nodes expanded=</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">counter_bidir</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">[</span><span class="token string-interpolation interpolation" style="color: rgb(54, 172, 170);">0</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">]</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> counter_bidir</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        ratio </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> counter_standard</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">/</span><span> counter_bidir</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Speedup: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">ratio</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">:</span><span class="token string-interpolation interpolation format-spec">.1f</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">x fewer node expansions"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>

<span>performance_comparison</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h2>KEY TAKEAWAY</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║   NEW CONCEPT LEARNED: BIDIRECTIONAL BFS                           ║
  ║                                                                    ║
  ║   1. THE CORE IDEA:                                                ║
  ║      → Search from BOTH start and goal simultaneously             ║
  ║      → When frontiers overlap → shortest path found               ║
  ║      → Reduces O(b^d) to O(b^(d/2)) — EXPONENTIAL speedup       ║
  ║                                                                    ║
  ║   2. THE IMPLEMENTATION TRICK:                                     ║
  ║      → Two sets: front_set and back_set                            ║
  ║      → Two visited: front_visited and back_visited                 ║
  ║      → Always expand the SMALLER frontier (balancing)              ║
  ║      → SWAP trick: swap labels to avoid code duplication           ║
  ║      → Check new neighbors against OTHER side's visited set        ║
  ║                                                                    ║
  ║   3. REQUIREMENTS:                                                 ║
  ║      → Must know BOTH start AND goal (can't search backward       ║
  ║        from unknown goal)                                          ║
  ║      → Graph must be unweighted (or use bidirectional Dijkstra,   ║
  ║        which is much more complex)                                 ║
  ║      → For directed graphs: need reverse graph for backward search║
  ║                                                                    ║
  ║   4. WHEN IT SHINES:                                               ║
  ║      → High branching factor (b &gt;&gt; 1)                              ║
  ║      → Significant depth (d &gt;&gt; 1)                                  ║
  ║      → State-space search (puzzles, word games, transformations)   ║
  ║      → Large implicit graphs                                       ║
  ║                                                                    ║
  ║   5. THE BROADER PATTERN: "MEET IN THE MIDDLE"                    ║
  ║      → Split problem in half, solve both halves, combine           ║
  ║      → Appears in: BFS, subset sum, 4-sum, crypto, etc.           ║
  ║      → Turns exponential into square-root of exponential           ║
  ║                                                                    ║
  ║   MANTRA:                                                          ║
  ║   "Know both ends? Search from both. Meet in the middle.           ║
  ║    Always expand the smaller side."                                 ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>PHASE 4 COMPLETE — RECAP</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║  PHASE 4 PROBLEMS COMPLETED (33-42):                               ║
  ║                                                                    ║
  ║  33. Floyd-Warshall        → All-pairs shortest path               ║
  ║  34. Bridges (Tarjan's)    → Critical edges                        ║
  ║  35. Articulation Points   → Critical nodes                        ║
  ║  36. SCC (Kosaraju's)      → Strongly connected components         ║
  ║  37. Alien Dictionary      → Graph construction + topo sort        ║
  ║  38. State-Space BFS       → Expanded state (keys, bitmask)       ║
  ║  39. 0-1 BFS               → Deque for {0,1} weights              ║
  ║  40. Swim in Rising Water  → Minimax Dijkstra on grid             ║
  ║  41. Eulerian Path         → Hierholzer's (use all edges once)    ║
  ║  42. Bidirectional BFS     → Search from both ends                 ║
  ║                                                                    ║
  ║  SKILLS UNLOCKED:                                                  ║
  ║    ✓ All-pairs shortest paths                                     ║
  ║    ✓ Finding critical infrastructure (bridges, cut vertices)       ║
  ║    ✓ Decomposing directed graphs into SCCs                        ║
  ║    ✓ Building graphs from non-obvious input                       ║
  ║    ✓ Expanding state space for constrained search                  ║
  ║    ✓ Optimized BFS for special weight structures                   ║
  ║    ✓ Modified Dijkstra for non-standard metrics                   ║
  ║    ✓ Eulerian path algorithms                                     ║
  ║    ✓ Meet-in-the-middle optimization                              ║
  ║                                                                    ║
  ║  READY FOR PHASE 5: EXPERT LEVEL                                   ║
  ║    → Network Flow, Matching, LCA, Tree DP, Graph DP,              ║
  ║      A* Search, 2-SAT, Centroid Decomposition                     ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
</div>
</div>

<!-- ========== data-index="23" ========== -->

        </div>

        <div class="nav-bar">
            <a href="problem-41.html" class="nav-button prev">← Previous Problem</a>
            <div class="page-info">
                <a href="index.html" class="nav-button home">📚 Table of Contents</a><br>
                <span style="margin-top:8px;display:block">Problem 42 of 50</span>
            </div>
            <a href="problem-43.html" class="nav-button next">Next Problem →</a>
        </div>
    </div>

    
    <div id="progress-track"><div id="progress-fill"></div></div>
    <div id="progress-pct">0%</div>


    <script>
    const fill = document.getElementById('progress-fill');
    const pct  = document.getElementById('progress-pct');
    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrolled  = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        fill.style.height = scrolled + '%';
        pct.textContent   = Math.round(scrolled) + '%';
    }
    window.addEventListener('scroll', updateProgress);
    updateProgress();

    document.addEventListener('keydown', function(e) {
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
        if (e.key === 'ArrowLeft') {
            const b = document.querySelector('.nav-button.prev');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
        if (e.key === 'ArrowRight') {
            const b = document.querySelector('.nav-button.next');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
    });
    </script>

</body>
</html>