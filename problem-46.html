<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 46: Problem 46: Tree DP (Maximum Path Sum) — Graph Algorithms Mastery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.75;
            color: #1a202c;
            background-color: #f7fafc;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.08);
            padding: 48px 52px;
        }
        
        .content { max-width: 950px; margin: 0 auto; color: #1a202c; }
        .content h1 {
            color: #1a202c; margin: 32px 0 20px;
            padding-bottom: 12px;
            border-bottom: 4px solid #10b981;
            font-size: 2.1em;
            font-weight: 700;
        }
        .content h2 {
            color: #1a202c; margin: 28px 0 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #34d399;
            font-size: 1.6em;
            font-weight: 600;
        }
        .content h3 { color: #1a202c; margin: 22px 0 12px; font-size: 1.3em; font-weight: 600; }
        .content h4 { color: #2d3748; margin: 18px 0 10px; font-size: 1.1em; font-weight: 600; }
        .content p  { margin-bottom: 16px; line-height: 1.8; color: #1a202c; }
        .content ul, .content ol { margin: 12px 0 18px 30px; color: #1a202c; }
        .content li { margin-bottom: 8px; line-height: 1.75; color: #1a202c; }
        .content hr { border: none; border-top: 2px solid #e2e8f0; margin: 26px 0; }
        .content pre {
            background: #f7fafc !important;
            border: 1px solid #cbd5e0 !important;
            border-left: 4px solid #10b981 !important;
            padding: 18px !important; overflow-x: auto; margin: 18px 0; border-radius: 6px;
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.9em !important;
        }
        .content pre:not([style*="color"]) { color: #1a202c !important; }
        .content code {
            font-family: 'Consolas','Monaco','Courier New',monospace !important;
            font-size: 0.88em !important;
        }
        .content code:not(pre code) {
            background: #d1fae5 !important;
            color: #1a202c !important;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .content pre code { background: transparent !important; padding: 0; }
        .content table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .content th {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white; padding: 12px 16px; text-align: left;
            font-weight: 600;
        }
        .content td { padding: 11px 16px; border: 1px solid #e2e8f0; color: #1a202c; }
        .content tr:nth-child(even) td { background: #ecfdf5; }
        .content blockquote {
            border-left: 4px solid #10b981; background: #ecfdf5;
            padding: 14px 20px; margin: 18px 0; border-radius: 0 6px 6px 0;
            color: #1a202c;
        }
        .content strong { color: #1a202c; font-weight: 600; }
        .px-2 { padding: 0; }
        .chat-message { background: transparent; padding: 0; margin: 0; }

        /* Bottom nav bar only */
        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 24px 0;
            margin-top: 50px;
            border-top: 3px solid #34d399;
        }
        .nav-button {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 12px 26px;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            color: white !important; text-decoration: none;
            border-radius: 8px; font-weight: 600; font-size: 0.95em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(16,185,129,0.35);
        }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 4px 14px rgba(16,185,129,0.5); }
        .nav-button.disabled { background: #cbd5e1; box-shadow: none; pointer-events: none; }
        .nav-button.home {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 2px 8px rgba(99,102,241,0.35);
        }
        .nav-button.home:hover { box-shadow: 0 4px 14px rgba(99,102,241,0.5); }
        .page-info { color: #718096; font-size: 0.9em; text-align: center; }

        /* Progress bar */
        #progress-track {
            position: fixed; top: 20px; right: 20px;
            width: 10px; height: 150px;
            background: rgba(16,185,129,0.2);
            border: 2px solid #10b981;
            border-radius: 6px; overflow: hidden; z-index: 1000;
        }
        #progress-fill {
            width: 100%;
            background: linear-gradient(180deg, #10b981, #059669);
            height: 0%;
            transition: height 0.15s ease;
        }
        #progress-pct {
            position: fixed; top: 0px; right: 16px;
            color: #059669; font-size: 14px; font-weight: bold;
            z-index: 1001;
            text-shadow: 0 1px 2px rgba(255,255,255,0.9);
            line-height: 20px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="chat-message" data-index="9">
<div class="px-2"><h1>Problem 46: Tree DP (Maximum Path Sum)</h1>
<h2>[Algorithm Family: Dynamic Programming on Trees / DFS + DP]</h2>
<h2>[Phase 5: Expert — "I can design solutions for novel graph problems"]</h2>
<hr>
<h2>PROBLEM STATEMENT</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>You manage a network of cities connected as a tree.
</span>Each city has a VALUE — it can be positive (profit) or negative (loss).

You want to find a PATH in this tree (any start, any end) 
that maximizes the TOTAL VALUE of all cities on the path.

A path must be a SIMPLE PATH (no repeated nodes).
The path can start and end at ANY nodes.
The path must contain at least one node.

Input:
  A tree with N nodes, each node has a value.
  
  Values: [-10, 2, 8, -3, 5, -1, 7, 4, -2, 6]
  
  Tree structure:
         0(-10)
        / \
      1(2)  2(8)
      / \     \
   3(-3) 4(5)  5(-1)
    /         / \
  6(7)     7(4) 8(-2)
              \
              9(6)

Output:
  Maximum path sum = ?
  (Find the path with highest total node values)

Constraints:
  → N up to 100,000
  → Node values can be negative (this is what makes it tricky!)
  → Path = contiguous sequence of nodes in the tree</code></pre></div>
<hr>
<h2>STEP 1: VISUALIZE FIRST — Draw the Tree with Values</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>              0(-10)
</span>             /      \
          1(2)      2(8)
         /    \        \
      3(-3)   4(5)    5(-1)
       /              /    \
     6(7)          7(4)   8(-2)
                     \
                     9(6)

  Edges (undirected tree):
    0-1, 0-2, 1-3, 1-4, 2-5, 3-6, 5-7, 5-8, 7-9
    
  N = 10, E = 9 (always N-1 for a tree)</code></pre></div>
<h3>Identify Graph Properties</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>╔═══════════════════════════════════════════════════════════════════╗
</span>║  Property        │  Answer            │  Why?                    ║
╠══════════════════╪════════════════════╪══════════════════════════╣
║  NODES           │  Cities 0-9        │  Each city = node        ║
║  EDGES           │  Roads             │  Undirected connections  ║
║  Directed?       │  NO                │  Roads go both ways      ║
║  Weighted?       │  NODE-weighted     │  Values on NODES not     ║
║                  │                    │  edges (unusual!)        ║
║  Cyclic?         │  NO                │  It's a tree             ║
║  Connected?      │  YES               │  Single tree             ║
║  Special         │  TREE with         │  DP natural on trees     ║
║                  │  node values       │  due to recursive struct ║
╚══════════════════╧════════════════════╧══════════════════════════╝</code></pre></div>
<h3>What Paths Look Like in a Tree</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  KEY INSIGHT from Problem 45 (LCA):
</span>  Every path in a tree has a HIGHEST POINT (the "turning point").
  
  The path goes UP from one end to the turning point,
  then DOWN from the turning point to the other end.
  
  Example paths and their sums:
  
  Path [6, 3]:         7 + (-3) = 4
  Path [6]:            7
  Path [4, 1, 3, 6]:  5 + 2 + (-3) + 7 = 11
  Path [9, 7, 5, 2]:  6 + 4 + (-1) + 8 = 17
  Path [4, 1, 0, 2]:  5 + 2 + (-10) + 8 = 5
  Path [9, 7]:         6 + 4 = 10
  
  The "turning point" concept:
  
  Path [4, 1, 3, 6]:
                1(2)         ← turning point (highest node on path)
               / \
            3(-3) 4(5)       ← path goes DOWN left and DOWN right
            /
          6(7)
          
  Path [9, 7, 5, 2]:
                2(8)         ← turning point
                 \
                5(-1)        ← path goes down
               /
             7(4)
              \
              9(6)
  
  EVERY path has exactly ONE node where the path "bends" —
  the path comes up from one subtree and goes down into another
  (or just goes down into one subtree).</code></pre></div>
<hr>
<h2>STEP 2: BRUTE FORCE FIRST — Enumerate All Paths</h2>
<h3>Approach: Try All Pairs</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  For every pair (u, v):
</span>    → Find the unique path from u to v in the tree
    → Sum up all node values on the path
    → Track maximum
    
  Number of pairs: N × (N-1) / 2 = 10 × 9 / 2 = 45
  
  For each pair: finding path takes O(N) (DFS/BFS)
                 summing takes O(path length) ≤ O(N)
  
  Total: O(N²) pairs × O(N) per pair = O(N³)</code></pre></div>
<h3>Why Brute Force Fails</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  N = 100,000
</span>  O(N³) = 10^15 → IMPOSSIBLY SLOW
  
  Even O(N²) = 10^10 → too slow
  
  We need O(N) — a single pass through the tree!
  
  KEY REALIZATION:
    → A tree has recursive structure
    → Each subtree is independent
    → We can solve subtrees first, then combine
    → This is DYNAMIC PROGRAMMING on a tree</code></pre></div>
<hr>
<h2>STEP 3: IDENTIFYING THE PATTERN</h2>
<h3>The DP on Trees Idea</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  CORE INSIGHT: Think from EACH NODE's perspective
  ═══════════════════════════════════════════════════════════════
  
  For each node, consider it as the TURNING POINT of a path.
  
  If node X is the turning point:
    → The path goes DOWN into at most TWO of X's subtrees
    → (Plus X itself)
    
  At node X, the best path through X =
    X's value
    + best downward chain from X's LEFT subtree (or 0 if negative)
    + best downward chain from X's RIGHT subtree (or 0 if negative)
    
  "Best downward chain from subtree" = 
    maximum sum path starting at X going DOWN through ONE child
    
  ═══════════════════════════════════════════════════════════════
  TWO THINGS TO TRACK AT EACH NODE:
  ═══════════════════════════════════════════════════════════════
  
  1. max_gain(node): 
     "Best sum I can contribute to my PARENT's path"
     = node's value + max(0, best single-child chain)
     This is a CHAIN (goes through at most one child)
     
  2. max_path_through(node):
     "Best path where THIS NODE is the turning point"
     = node's value + max(0, best left chain) + max(0, best right chain)
     This CANNOT be passed up (path bends here)
     
  Global answer = max of max_path_through(node) for ALL nodes
  
  ═══════════════════════════════════════════════════════════════
  WHY max(0, ...)?
  ═══════════════════════════════════════════════════════════════
  
  If a subtree's best chain is NEGATIVE, we simply DON'T extend 
  into that subtree! We "cut" the path there.
  
  This is the crucial optimization: negative chains are worse 
  than no chain at all.</code></pre></div>
<h3>Visual Explanation</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  At node 1(2):
</span>  
           1(2)          ← considering this as turning point
          / \
       3(-3) 4(5)
       /
     6(7)
     
  Left subtree best chain going down from 1:
    1 → 3 → 6: values -3 + 7 = 4
    1 → 3:     value -3
    Best chain from left child 3 = max(-3 + 7, -3) = 4
    
  Right subtree best chain going down from 1:
    1 → 4: value 5
    Best chain from right child 4 = 5
    
  max_gain(1) = 2 + max(4, 5) = 2 + 5 = 7
    "If my parent wants to use me, best I offer is 7 (going through 4)"
    
  max_path_through(1) = 2 + max(0, 4) + max(0, 5) = 2 + 4 + 5 = 11
    "Best path with me as turning point: 6→3→1→4 with sum 7+(-3)+2+5=11"
    
  NOTE: max_gain uses ONE best child (chain to parent)
        max_path_through uses TWO best children (path bends here)</code></pre></div>
<h3>The Recurrence</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  For a leaf node:
</span>    max_gain(leaf) = leaf.value
    max_path_through(leaf) = leaf.value
    
  For an internal node with children c1, c2, ..., ck:
    
    child_gains = [max_gain(ci) for ci in children]
    
    max_gain(node) = node.value + max(0, max(child_gains))
      → Pick the BEST child chain (or none if all negative)
      → This is what we RETURN to parent
      
    max_path_through(node) = node.value 
                            + sum of top-2 positive child_gains
      → Pick the BEST TWO child chains (or one, or none)
      → This is a CANDIDATE for the global answer
      → But we do NOT return this to parent (path bends!)
      
  Global answer = max over all nodes of max_path_through(node)</code></pre></div>
<hr>
<h2>STEP 4: ALGORITHM WALKTHROUGH</h2>
<h3>Step-by-Step DFS Trace</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Tree (rooted at 0 for DFS, but path can start/end anywhere):
</span>  
              0(-10)
             /      \
          1(2)      2(8)
         /    \        \
      3(-3)   4(5)    5(-1)
       /              /    \
     6(7)          7(4)   8(-2)
                     \
                     9(6)

  DFS post-order processes LEAVES first, then internal nodes.
  Order: 6, 3, 4, 1, 9, 7, 8, 5, 2, 0
  
  global_max = -infinity (will be updated at each node)</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ NODE 6 (value = 7) — LEAF                                    │
  │                                                              │
  │   Children: none                                              │
  │   child_gains = []                                            │
  │                                                              │
  │   max_gain(6) = 7 + max(0, nothing) = 7                     │
  │     "I offer 7 to my parent"                                  │
  │                                                              │
  │   max_path_through(6) = 7                                     │
  │     "Best path using me as turning point = just me"          │
  │                                                              │
  │   global_max = max(-inf, 7) = 7                               │
  │                                                              │
  │   Return to parent: max_gain = 7                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 3 (value = -3) — has child 6                            │
  │                                                              │
  │      3(-3)                                                    │
  │      /                                                        │
  │    6(7)  ← max_gain = 7                                      │
  │                                                              │
  │   child_gains = [7]                                           │
  │                                                              │
  │   max_gain(3) = -3 + max(0, 7) = -3 + 7 = 4                 │
  │     "Best chain down from me: -3 + 7 = 4"                   │
  │     "I offer 4 to my parent (path 3→6)"                      │
  │                                                              │
  │   max_path_through(3) = -3 + max(0, 7) = 4                  │
  │     "Only one child, so path is chain: 6→3 = 4"             │
  │     (Can't bend with only one child subtree)                 │
  │                                                              │
  │   global_max = max(7, 4) = 7                                  │
  │                                                              │
  │   Return to parent: max_gain = 4                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 4 (value = 5) — LEAF                                    │
  │                                                              │
  │   max_gain(4) = 5                                             │
  │   max_path_through(4) = 5                                     │
  │   global_max = max(7, 5) = 7                                  │
  │                                                              │
  │   Return to parent: max_gain = 5                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 1 (value = 2) — has children 3 and 4                    │
  │                                                              │
  │        1(2)                                                   │
  │       /    \                                                  │
  │    3(-3)   4(5)                                               │
  │    /                                                          │
  │  6(7)                                                         │
  │                                                              │
  │   child_gains from 3: 4  (chain 3→6)                         │
  │   child_gains from 4: 5  (just node 4)                       │
  │   child_gains = [4, 5]                                        │
  │                                                              │
  │   max_gain(1) = 2 + max(0, max(4, 5)) = 2 + 5 = 7          │
  │     "Best chain: 1→4 with sum 2+5 = 7"                      │
  │     "I offer 7 to my parent"                                  │
  │     NOTE: we pick ONE best child (5 &gt; 4), not both           │
  │                                                              │
  │   max_path_through(1):                                        │
  │     Top-2 positive child gains: [5, 4] (both positive)       │
  │     = 2 + 5 + 4 = 11                                         │
  │     "Path: 4→1→3→6 with sum 5+2+(-3)+7 = 11"               │
  │     "Or equivalently: 6→3→1→4 = 7+(-3)+2+5 = 11"           │
  │                                                              │
  │   ★ THIS is where the path BENDS at node 1                   │
  │     Going through BOTH children makes a better path          │
  │     than just going through one!                              │
  │                                                              │
  │   global_max = max(7, 11) = 11  ★ NEW BEST!                  │
  │                                                              │
  │   Return to parent: max_gain = 7  (NOT 11!)                  │
  │     WHY? Because 11 is a BENT path (uses both children).     │
  │     Parent can only extend a CHAIN (one direction).           │
  │     Best chain through 1 = 7 (going 1→4).                   │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Critical Distinction: What We RETURN vs What We RECORD</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════╗
</span>  ║                                                              ║
  ║  At node 1:                                                  ║
  ║                                                              ║
  ║  RETURN to parent: max_gain = 7 (chain: 1→4)                ║
  ║    → Parent can EXTEND this chain further up                 ║
  ║    → This is a STRAIGHT LINE from node 1 downward           ║
  ║                                                              ║
  ║  RECORD globally: max_path = 11 (bent: 6→3→1→4)            ║
  ║    → This path CANNOT be extended by parent                  ║
  ║    → It already uses two subtrees (bends at node 1)         ║
  ║    → Adding parent would create a "T-shape" = NOT a path    ║
  ║                                                              ║
  ║  This is THE KEY INSIGHT of tree path DP:                    ║
  ║    "What I return ≠ what I record"                           ║
  ║                                                              ║
  ╚══════════════════════════════════════════════════════════════╝
  
  Visually:
  
  CHAIN (can extend):        BENT PATH (cannot extend):
  
       ↑ to parent                ✗ cannot go to parent
       |                          |
       1(2)                      1(2)
        \                       / \
        4(5)                 3(-3) 4(5)
                             /
   "Straight line"         6(7)
   "Parent can continue     
    upward"               "Path bends at 1"
                          "Adding parent would make T-shape"</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ NODE 9 (value = 6) — LEAF                                    │
  │                                                              │
  │   max_gain(9) = 6                                             │
  │   max_path_through(9) = 6                                     │
  │   global_max = max(11, 6) = 11                                │
  │                                                              │
  │   Return to parent: max_gain = 6                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 7 (value = 4) — has child 9                             │
  │                                                              │
  │      7(4)                                                     │
  │        \                                                      │
  │        9(6)  ← max_gain = 6                                  │
  │                                                              │
  │   child_gains = [6]                                           │
  │                                                              │
  │   max_gain(7) = 4 + max(0, 6) = 10                           │
  │     "Chain: 7→9 with sum 4+6 = 10"                          │
  │                                                              │
  │   max_path_through(7) = 4 + 6 = 10                           │
  │     "Path: 7→9 = 10"                                        │
  │                                                              │
  │   global_max = max(11, 10) = 11                               │
  │                                                              │
  │   Return to parent: max_gain = 10                             │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 8 (value = -2) — LEAF                                   │
  │                                                              │
  │   max_gain(8) = -2                                            │
  │   max_path_through(8) = -2                                    │
  │   global_max = max(11, -2) = 11                               │
  │                                                              │
  │   Return to parent: max_gain = -2                             │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 5 (value = -1) — has children 7 and 8                   │
  │                                                              │
  │       5(-1)                                                   │
  │      /    \                                                   │
  │    7(4)   8(-2)                                               │
  │      \                                                        │
  │      9(6)                                                     │
  │                                                              │
  │   child_gains from 7: 10  (chain 7→9)                        │
  │   child_gains from 8: -2  (just node 8)                      │
  │   child_gains = [10, -2]                                      │
  │                                                              │
  │   max_gain(5) = -1 + max(0, max(10, -2)) = -1 + 10 = 9     │
  │     "Best chain: 5→7→9 with sum -1+4+6 = 9"                │
  │                                                              │
  │   max_path_through(5):                                        │
  │     Positive child gains: [10] (only 10; -2 is negative)    │
  │     = -1 + 10 + max(0, -2) = -1 + 10 + 0 = 9               │
  │     "Child 8's gain is negative → don't include it"          │
  │     "Path: 9→7→5 = 6+4+(-1) = 9"                           │
  │                                                              │
  │   global_max = max(11, 9) = 11                                │
  │                                                              │
  │   Return to parent: max_gain = 9                              │
  └──────────────────────────────────────────────────────────────┘
  
  ┌──────────────────────────────────────────────────────────────┐
  │ NODE 2 (value = 8) — has child 5                             │
  │                                                              │
  │       2(8)                                                    │
  │        \                                                      │
  │       5(-1)  ← max_gain = 9                                  │
  │      /    \                                                   │
  │    7(4)   8(-2)                                               │
  │      \                                                        │
  │      9(6)                                                     │
  │                                                              │
  │   child_gains = [9]                                           │
  │                                                              │
  │   max_gain(2) = 8 + max(0, 9) = 17                           │
  │     "Chain: 2→5→7→9 with sum 8+(-1)+4+6 = 17"              │
  │                                                              │
  │   max_path_through(2) = 8 + 9 = 17                           │
  │     "Path: 9→7→5→2 = 6+4+(-1)+8 = 17"                      │
  │                                                              │
  │   global_max = max(11, 17) = 17  ★ NEW BEST!                 │
  │                                                              │
  │   Return to parent: max_gain = 17                             │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────────┐
</span>  │ NODE 0 (value = -10) — ROOT, has children 1 and 2            │
  │                                                              │
  │              0(-10)                                            │
  │             /      \                                          │
  │          1(2)      2(8)                                       │
  │                                                              │
  │   child_gains from 1: 7   (chain 1→4)                        │
  │   child_gains from 2: 17  (chain 2→5→7→9)                   │
  │   child_gains = [7, 17]                                       │
  │                                                              │
  │   max_gain(0) = -10 + max(0, max(7, 17)) = -10 + 17 = 7    │
  │     "Best chain through root: 0→2→5→7→9 = -10+8-1+4+6 = 7" │
  │                                                              │
  │   max_path_through(0):                                        │
  │     Top-2 positive child gains: [17, 7]                       │
  │     = -10 + 17 + 7 = 14                                      │
  │     "Path: 9→7→5→2→0→1→4 = 6+4-1+8-10+2+5 = 14"           │
  │                                                              │
  │   global_max = max(17, 14) = 17                               │
  │     Path through 0 (14) is WORSE than path 9→7→5→2 (17)     │
  │     because node 0 has value -10 which drags it down!        │
  │                                                              │
  │   Return: (root, nothing to return to)                        │
  └──────────────────────────────────────────────────────────────┘</code></pre></div>
<h3>Final Summary of All Computations</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────┬───────┬────────────┬─────────────────┬─────────────────────────┐
</span>  │ Node │ Value │ max_gain   │ max_path_through│ Explanation              │
  ├──────┼───────┼────────────┼─────────────────┼─────────────────────────┤
  │  6   │   7   │     7      │       7         │ Leaf                    │
  │  3   │  -3   │     4      │       4         │ Chain: 3→6              │
  │  4   │   5   │     5      │       5         │ Leaf                    │
  │  1   │   2   │     7      │      11 ★       │ Bent: 6→3→1→4          │
  │  9   │   6   │     6      │       6         │ Leaf                    │
  │  7   │   4   │    10      │      10         │ Chain: 7→9              │
  │  8   │  -2   │    -2      │      -2         │ Leaf (negative)         │
  │  5   │  -1   │     9      │       9         │ Chain: 5→7→9           │
  │  2   │   8   │    17      │      17 ★★      │ Chain: 2→5→7→9         │
  │  0   │ -10   │     7      │      14         │ Bent: 4→1→0→2→5→7→9   │
  └──────┴───────┴────────────┴─────────────────┴─────────────────────────┘
  
  ANSWER: max(all max_path_through) = 17
  
  Best path: 9 → 7 → 5 → 2
  Sum: 6 + 4 + (-1) + 8 = 17
  
  ═══════════════════════════════════════════════════════════════
  WHY NOT the longer path through node 0?
  ═══════════════════════════════════════════════════════════════
  
  Path 9→7→5→2→0→1→4: 6+4+(-1)+8+(-10)+2+5 = 14
  
  Including node 0 (value -10) HURTS the total!
  So the optimal path STOPS at node 2 and doesn't cross to 0.
  
  This is why max(0, child_gain) is crucial:
  Node 2 looks at its parent 0 direction and effectively says:
  "Going through 0 costs -10, not worth it — I'll stop here."
  
  (In our DFS, we process bottom-up, so node 2 doesn't actually
   look at its parent. Instead, node 0 looks at child 2's gain
   and the -10 at node 0 makes the through-path worse.)</code></pre></div>
<hr>
<h2>STEP 5: COMPLETE CODE</h2>
<h3>Version 1: Recursive DFS (Clean, Intuitive)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">max_path_sum_tree</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Find the maximum path sum in a node-weighted tree.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    A path is any simple path (contiguous, no repeated nodes).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Each node has a value (can be negative).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Algorithm: DFS from root, at each node:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      1. Collect max_gain from each child
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      2. Compute max_path_through (using top 2 child gains)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      3. Update global answer
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      4. Return max_gain (best single-direction chain) to parent
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Built on:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 1:  Adjacency list representation
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 4:  DFS traversal (recursion)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - Problem 45: LCA taught us "every tree path has a turning point"
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Time:  O(N) — visit each node once
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Space: O(N) — recursion stack + adjacency list
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Build adjacency list (Problem 1) ───</span><span>
</span><span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Global answer ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Must handle all-negative case: minimum valid path = single node</span><span>
</span><span>    global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'-inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># list for mutability in nested function</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Returns max_gain(node):
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            The maximum sum achievable by a CHAIN starting at this node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            and going DOWN into exactly ONE subtree (or no subtree).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        Also updates global_max with max_path_through(node):
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            The maximum sum achievable by a PATH that BENDS at this node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            (going through at most TWO subtrees).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        """</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Start with just this node's value</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># max_gain = node's value + best single child chain (or 0)</span><span>
</span><span>        node_val </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Collect gains from all children</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># (In a tree traversed from root, "children" = neighbors except parent)</span><span>
</span><span>        child_gains </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># don't go back to parent</span><span>
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                child_gains</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gain</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Compute max_gain (what we return to parent) ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Best single child chain, or 0 if all negative</span><span>
</span><span>        best_child </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>child_gains</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> child_gains </span><span class="token" style="color: rgb(0, 0, 255);">else</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span><span>        best_child </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>best_child</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># don't extend if all negative</span><span>
</span>        
<span>        max_gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best_child
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Compute max_path_through (update global) ───</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Use top-2 positive child gains</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Sort descending, take top 2 (if positive)</span><span>
</span>        
<span>        positive_gains </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">sorted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>g </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> g </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> child_gains </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> g </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> reverse</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">True</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        path_sum </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>positive_gains</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            path_sum </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> positive_gains</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>       </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># best child direction</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>positive_gains</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            path_sum </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> positive_gains</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>       </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># second best child direction</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Update global answer</span><span>
</span><span>        global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_sum</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> max_gain
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Run DFS from node 0 as root ───</span><span>
</span><span>    dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ═══════════════════════════════════════════════════════════════</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  TEST</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ═══════════════════════════════════════════════════════════════</span><span>
</span>
<span>n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>values </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>
<span>result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> max_path_sum_tree</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Maximum path sum: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">result</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Expected: 17 (path: 9→7→5→2)</span></code></pre></div>
<p><strong>Output:</strong></p>
<code>Maximum path sum: 17</code>
<hr>
<h3>Version 2: Optimized (No Sorting, O(N) Guaranteed)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">max_path_sum_optimized</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Optimized version: find top-2 child gains WITHOUT sorting.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Instead of sorting all child gains (O(k log k) per node),
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    track just the top-2 in a single pass (O(k) per node).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Total: O(N) guaranteed (each edge visited twice = O(E) = O(N))
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'-inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node_val </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Track top-2 child gains (positive only)</span><span>
</span><span>        best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>   </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># best child gain (≥ 0)</span><span>
</span><span>        best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>   </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># second best child gain (≥ 0)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> neighbor </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> neighbor </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>neighbor</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Clamp to 0: negative gains are useless</span><span>
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gain</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Update top-2</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> best1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> best1
</span><span>                    best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">elif</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># max_gain: this node + best single child chain</span><span>
</span><span>        max_gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best1
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># max_path_through: this node + top-2 child chains</span><span>
</span><span>        path_through </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best1 </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best2
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Update global</span><span>
</span><span>        global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_through</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> max_gain
</span>    
<span>    dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>values </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Maximum path sum: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">max_path_sum_optimized</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">n</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> edges</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> values</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 17</span></code></pre></div>
<hr>
<h3>Version 3: Iterative DFS (Avoids Recursion Limit)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">max_path_sum_iterative</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Iterative version for large trees (N &gt; 10,000).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Python's default recursion limit is ~1000.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    For N = 100,000 (skewed tree), recursion would crash.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Strategy: compute DFS post-order iteratively,
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    then process nodes in post-order.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is important for competitive programming where
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    trees can be very deep (Problem 4 DFS iterative version).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Step 1: Find post-order and parent via iterative DFS ───</span><span>
</span><span>    parent </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    order </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>         </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># post-order</span><span>
</span><span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    stack </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># First pass: DFS to get tree structure</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># We need a way to process children before parents</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Use a trick: push node, then when we pop and all children done, add to order</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Simpler approach: BFS to get parent[], then reverse BFS order = post-order</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> deque
</span><span>    queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    bfs_order </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        bfs_order</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node
</span><span>                queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Reverse BFS order = process leaves before roots (post-order-like)</span><span>
</span><span>    post_order </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> bfs_order</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Step 2: Process in post-order ───</span><span>
</span><span>    max_gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># max_gain[node] = best chain from node downward</span><span>
</span><span>    global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'-inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> post_order</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node_val </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>        best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># top child gain (clamped to 0)</span><span>
</span><span>        best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># second best</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># nei is a child</span><span>
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>max_gain</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> best1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> best1
</span><span>                    best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">elif</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span>        
<span>        max_gain</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best1
</span><span>        path_through </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node_val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best1 </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best2
</span><span>        global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>global_max</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_through</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> global_max
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">10</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">9</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>values </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Maximum path sum (iterative): </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">max_path_sum_iterative</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">n</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> edges</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">,</span><span class="token string-interpolation interpolation"> values</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<hr>
<h3>Version 4: LeetCode 124 — Binary Tree Maximum Path Sum</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Definition for a binary tree node.</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">__init__</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> val</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> left</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">None</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> right</span><span class="token" style="color: rgb(57, 58, 52);">=</span><span class="token" style="color: rgb(54, 172, 170);">None</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>val </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> val
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> left
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> right
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">Solution</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LeetCode 124: Binary Tree Maximum Path Sum
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Same algorithm but on a binary tree (max 2 children per node).
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Simpler because we always have at most left and right.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is the CLASSIC interview version of this problem.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">maxPathSum</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">float</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(163, 21, 21);">'-inf'</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            Returns max_gain: max sum chain going DOWN from this node.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            Updates global_max with best path THROUGH this node.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">            """</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Get gains from left and right subtrees</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Clamp to 0: if a subtree's gain is negative, don't use it</span><span>
</span><span>            left_gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            right_gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Path through this node (this node is the turning point)</span><span>
</span><span>            path_through </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> left_gain </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> right_gain
</span><span>            self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>global_max</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> path_through</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Return: best chain going DOWN (pick ONE direction)</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>left_gain</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> right_gain</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> self</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>global_max
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Build tree for testing ───</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#        -10</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#        / \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#       2    8</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#      / \    \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#    -3   5   -1</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#    /        / \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   7        4  -2</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#             \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#              6</span><span>
</span>
<span>root </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">10</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">8</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">7</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">6</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>
<span>sol </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> Solution</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"LeetCode 124 answer: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">sol</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">.</span><span class="token string-interpolation interpolation">maxPathSum</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation interpolation">root</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">)</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 17</span></code></pre></div>
<hr>
<h2>STEP 6: COMPLEXITY ANALYSIS</h2>
<h3>Time Complexity: O(N)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────┐
</span>  │  Operation                    │  Time                    │
  ├──────────────────────────────┼──────────────────────────┤
  │  Build adjacency list         │  O(N) — N-1 edges       │
  │  DFS traversal                │  O(N) — visit each once │
  │  At each node: process kids   │  O(degree(node))        │
  │  Total kid processing         │  O(sum of degrees) = O(N)│
  ├──────────────────────────────┼──────────────────────────┤
  │  TOTAL                        │  O(N)                    │
  └──────────────────────────────┴──────────────────────────┘
  
  WHY O(N)?
  
  Each node visited exactly once in DFS.
  At each node, we iterate its children.
  Sum of all children counts = sum of all degrees = 2(N-1) for a tree.
  Total work = O(N) + O(2(N-1)) = O(N).
  
  KEY: No sorting needed! Top-2 in O(k) per node,
       total across all nodes = O(N).</code></pre></div>
<h3>Space Complexity: O(N)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌──────────────────────────────────────────────────────────┐
</span>  │  Component                    │  Space                   │
  ├──────────────────────────────┼──────────────────────────┤
  │  Adjacency list               │  O(N)                    │
  │  Recursion stack              │  O(H) where H = height   │
  │  (worst case: skewed tree)    │  O(N)                    │
  │  (best case: balanced tree)   │  O(log N)                │
  ├──────────────────────────────┼──────────────────────────┤
  │  TOTAL                        │  O(N) worst case         │
  └──────────────────────────────┴──────────────────────────┘
  
  The iterative version (Version 3) uses O(N) explicitly 
  for the post-order array, but avoids recursion stack overflow.</code></pre></div>
<hr>
<h2>STEP 7: WHY THIS IS "DP" ON TREES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  WHAT MAKES THIS DYNAMIC PROGRAMMING?
  ═══════════════════════════════════════════════════════════════
  
  DP has three properties:
    1. Optimal substructure: 
       Best path through node X uses best chains from X's subtrees
       → Solving children FIRST gives us what we need for X
       ✓ YES
       
    2. Overlapping subproblems:
       In trees, each subtree is computed ONCE (no overlap)
       → Actually, tree DP is more like divide-and-conquer
       → But we call it "DP" because the thinking is the same
       ✓ PARTIALLY (structure, not overlapping)
       
    3. Bottom-up computation:
       Compute leaves first, then their parents, up to root
       → DFS post-order naturally does this
       ✓ YES
       
  ═══════════════════════════════════════════════════════════════
  THE DP TABLE (implicit in recursion):
  ═══════════════════════════════════════════════════════════════
  
  State:    max_gain[node]
  Meaning:  Best sum of a downward chain starting at node
  
  Transition:
    max_gain[leaf] = leaf.value
    max_gain[node] = node.value + max(0, max(max_gain[child] for child))
    
  Global answer computed as side effect:
    At each node: node.value + top_2_positive(max_gain[children])
    
  ═══════════════════════════════════════════════════════════════
  TREE DP TEMPLATE (generalizes to MANY problems):
  ═══════════════════════════════════════════════════════════════
  
  def dfs(node, parent):
      # 1. Recursively solve all children
      results = []
      for child in adj[node]:
          if child != parent:
              results.append(dfs(child, node))
      
      # 2. Combine children's results for THIS node
      answer_for_node = combine(node_value, results)
      
      # 3. Maybe update global answer
      update_global(answer_for_node)
      
      # 4. Return what PARENT needs
      return what_parent_needs(node_value, results)
      
  The key: what you RETURN may differ from what you RECORD.</code></pre></div>
<hr>
<h2>STEP 8: VARIATIONS AND EXTENSIONS</h2>
<h3>Variation 1: Maximum Path Sum with Edge Weights</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">max_path_sum_edge_weighted</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Instead of node values, edges have weights.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Find path with maximum total edge weight.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Change: max_gain(node) = max(0, max(weight + max_gain(child)))
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    No node value to add.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is "tree diameter with weights" problem.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> weighted_edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> w</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    global_max </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># minimum path has 0 edges</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span><span>        best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> weight </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> weight
</span><span>                gain </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>gain</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> best1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> best1
</span><span>                    best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">elif</span><span> gain </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> gain
</span>        
<span>        global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> best1 </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> best1
</span>    
<span>    dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> global_max</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span></code></pre></div>
<h3>Variation 2: Tree Diameter (Longest Path in Unweighted Tree)</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">tree_diameter</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Find the longest path (most edges) in an unweighted tree.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    This is the SIMPLEST tree DP:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - All node "values" = 1 (or 0 for edges-only counting)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - max_gain = longest chain down
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      - max_path_through = longest path bending here
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Equivalent to edge-weighted tree with all weights = 1.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Also solvable with "two BFS" trick:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      BFS from any node → find farthest node A
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      BFS from A → find farthest node B
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Distance(A, B) = diameter
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    But DP approach generalizes better.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    diameter </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Returns depth of deepest leaf in subtree."""</span><span>
</span><span>        best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># deepest child subtree</span><span>
</span><span>        best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># second deepest</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                depth </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># +1 for the edge</span><span>
</span>                
<span>                </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">&gt;=</span><span> best1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> best1
</span><span>                    best1 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> depth
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">elif</span><span> depth </span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                    best2 </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> depth
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Path through this node = best1 + best2 edges</span><span>
</span><span>        diameter</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>diameter</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> best1 </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> best2</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> best1
</span>    
<span>    dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> diameter</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#     0</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#    / \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   1   2</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  /     \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 3       4</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Diameter = 4 (path: 3→1→0→2→4)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>tree_diameter</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">5</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 4</span></code></pre></div>
<hr>
<h3>Variation 3: Count Paths with Sum Equal to Target</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">count_paths_with_sum</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Count the number of paths in the tree where the sum 
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    of node values equals exactly 'target'.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Uses prefix sum technique + DFS.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Similar to "subarray sum equals k" but on a tree.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    At each node during DFS:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      prefix_sum = sum of values from root to this node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      If prefix_sum - target exists in ancestor prefix sums
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        → there's a path ending here with sum = target
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Time: O(N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Space: O(N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> Counter
</span>    
<span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    count </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>    prefix_counts </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> Counter</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">{</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">}</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># empty prefix has sum 0</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> prefix_sum</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        prefix_sum </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> values</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># How many ancestor prefixes give us exactly 'target'?</span><span>
</span><span>        count</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> prefix_counts</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>prefix_sum </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> target</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Add current prefix to map</span><span>
</span><span>        prefix_counts</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>prefix_sum</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> prefix_sum</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Backtrack: remove current prefix (leaving this subtree)</span><span>
</span><span>        prefix_counts</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>prefix_sum</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span>
</span>    
<span>    dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> count</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span></code></pre></div>
<hr>
<h2>STEP 9: THE TREE DP PATTERN CATALOG</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  TREE DP PROBLEMS ALL FOLLOW THIS TEMPLATE:
  ═══════════════════════════════════════════════════════════════
  
  ┌───────────────────────────┬─────────────────────────────────────┐
  │  Problem                  │  What DFS returns / records          │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Max Path Sum             │  Return: best chain down             │
  │  (this problem)           │  Record: best bent path              │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Tree Diameter            │  Return: max depth                   │
  │                           │  Record: max depth1 + depth2         │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Subtree Size             │  Return: size of subtree             │
  │                           │  Record: nothing extra               │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Subtree Sum              │  Return: sum of subtree values       │
  │                           │  Record: nothing extra               │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Max Independent Set      │  Return: (include_me, exclude_me)    │
  │  (House Robber on tree)   │  Record: max of both at root         │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Min Vertex Cover         │  Return: (covered, not_covered)      │
  │                           │  Record: min at root                 │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Tree Coloring            │  Return: min cost per color          │
  │                           │  Record: min total at root           │
  ├───────────────────────────┼─────────────────────────────────────┤
  │  Rerooting (sum of        │  Return: subtree contribution        │
  │  distances to all nodes)  │  Record: answer for each root        │
  └───────────────────────────┴─────────────────────────────────────┘
  
  COMMON THREAD:
    → DFS post-order (solve children first)
    → Combine children's answers
    → What you RETURN to parent may differ from what you RECORD globally
    → O(N) time if combination is O(degree) per node</code></pre></div>
<hr>
<h2>STEP 10: BONUS — HOUSE ROBBER III (Tree DP Classic)</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">class</span><span> </span><span class="token" style="color: rgb(43, 145, 175);">Solution</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LeetCode 337: House Robber III
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Each node has a value. You can't rob two directly connected nodes.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Find maximum total value you can rob.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Tree DP with TWO states per node:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      rob(node):     max value if we DO rob this node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      not_rob(node): max value if we DON'T rob this node
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Transitions:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      rob(node) = node.val + sum(not_rob(child) for child in children)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        → If I rob myself, I CANNOT rob my children
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      not_rob(node) = sum(max(rob(child), not_rob(child)) for child in children)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">        → If I don't rob myself, each child can be robbed or not (pick best)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">rob</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>self</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> root</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span> TreeNode</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(57, 58, 52);">&gt;</span><span> </span><span class="token builtin">int</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""Returns (rob_this, not_rob_this)."""</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            left_rob</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> left_not </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>left</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>            right_rob</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> right_not </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>right</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Rob this node: can't rob children</span><span>
</span><span>            rob_this </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>val </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> left_not </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> right_not
</span>            
<span>            </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Don't rob this node: children are free to be robbed or not</span><span>
</span><span>            not_rob_this </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>left_rob</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> left_not</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>right_rob</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> right_not</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>            
<span>            </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>rob_this</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> not_rob_this</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>        
<span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token builtin">max</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>dfs</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>root</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">)</span></code></pre></div>
<h3>Why This is the Same Pattern</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Max Path Sum:
</span>    dfs returns: max_gain (chain)
    dfs records: max_path_through (bent path)
    
  House Robber III:
    dfs returns: (rob_me, dont_rob_me)
    parent uses: BOTH values to make its decision
    
  SAME TEMPLATE:
    1. Solve children
    2. Combine
    3. Return what parent needs</code></pre></div>
<hr>
<h2>STEP 11: WHAT IF THE GRAPH WERE...</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  WHAT IF: General graph (not a tree)?
  ═══════════════════════════════════════════════════════════════
  
  Maximum path sum in a general graph is NP-hard 
  (related to longest path problem).
  
  Trees are special because:
    → Unique path between any two nodes
    → No cycles → natural recursive structure
    → Post-order DFS gives optimal substructure
  
  For general graphs: would need exponential algorithms
  (or approximation).
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: DAG (directed acyclic graph)?
  ═══════════════════════════════════════════════════════════════
  
  → Use topological sort + DP (Problem 47 — next problem!)
  → Process nodes in topological order
  → At each node: dp[node] = node_val + max(dp[predecessor])
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: All values are positive?
  ═══════════════════════════════════════════════════════════════
  
  Then the answer is simply the sum of ALL node values!
  Every extension helps. The optimal path uses ALL nodes.
  Wait — that's not a path, that's the whole tree.
  
  Actually NO: a path must be a SIMPLE PATH (line, not tree).
  So even with all positives, we still need this DP to find 
  which LINE through the tree has maximum sum.
  
  But max(0, gain) is always just gain (no clamping needed).
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: Need to find the ACTUAL path (not just the sum)?
  ═══════════════════════════════════════════════════════════════
  
  Track which children were chosen at each node.
  When global_max is updated, record the current node and 
  the two (or one) child chains that formed the best path.
  
  Reconstruct by following the recorded choices.
  
  ═══════════════════════════════════════════════════════════════
  WHAT IF: Path must have at least K nodes?
  ═══════════════════════════════════════════════════════════════
  
  Need to track path LENGTH as additional state:
    dfs returns: (max_gain, length) for each possible length
    More complex, but same tree DP framework</code></pre></div>
<hr>
<h2>STEP 12: CONNECTIONS TO PREVIOUS AND FUTURE PROBLEMS</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌─────────────────────────────────────────────────────────────────┐
</span>  │  BUILDS ON:                                                     │
  │                                                                 │
  │  Problem 1:  Adjacency list to store the tree                  │
  │  Problem 4:  DFS traversal — the backbone of tree DP           │
  │  Problem 5:  Connected components — tree is one component      │
  │  Problem 45: LCA — taught us "every tree path has a           │
  │              turning point" which is exactly what we exploit:   │
  │              each node is a CANDIDATE turning point             │
  ├─────────────────────────────────────────────────────────────────┤
  │  ENABLES:                                                       │
  │                                                                 │
  │  Problem 47: Graph DP on DAGs — same "bottom-up DP" thinking  │
  │              but using topological sort instead of DFS          │
  │              Tree DP is actually a SPECIAL CASE of DAG DP      │
  │              (tree is a DAG when rooted)                        │
  │  Problem 50: Centroid decomposition — uses tree DP ideas       │
  │              to answer path queries efficiently                 │
  └─────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 13: COMMON PITFALLS AND EDGE CASES</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔══════════════════════════════════════════════════════════════╗
</span>  ║  PITFALL 1: Forgetting to clamp child gains to 0            ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  WRONG:                                                      ║
  ║    max_gain = node_val + max(child_gains)                    ║
  ║    → If best child is -5, we'd extend into it!               ║
  ║                                                              ║
  ║  RIGHT:                                                      ║
  ║    max_gain = node_val + max(0, max(child_gains))            ║
  ║    → Negative child? Don't extend. Path stops here.          ║
  ║                                                              ║
  ║  This handles the "path can start/end anywhere" property.    ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 2: Returning path_through instead of max_gain       ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  WRONG:                                                      ║
  ║    return node_val + best1 + best2                           ║
  ║    → This is a BENT path — parent can't extend it!           ║
  ║                                                              ║
  ║  RIGHT:                                                      ║
  ║    return node_val + best1  (single direction only)          ║
  ║    → This is a CHAIN — parent CAN extend it upward           ║
  ║                                                              ║
  ║  VISUAL of why bent path can't be extended:                  ║
  ║                                                              ║
  ║       parent                                                 ║
  ║         |                                                    ║
  ║        node       ← if path bends here (uses 2 children)    ║
  ║       /    \                                                 ║
  ║     child1  child2  ← both used                              ║
  ║                                                              ║
  ║  Adding parent would create:                                 ║
  ║                                                              ║
  ║       parent                                                 ║
  ║         |                                                    ║
  ║        node       ← THREE connections! NOT a simple path     ║
  ║       /    \                                                 ║
  ║     child1  child2                                           ║
  ║                                                              ║
  ║  A simple path through node uses at most 2 connections:      ║
  ║  one "in" and one "out". The bent path already uses both.    ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 3: All-negative values                              ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  Tree:   -5                                                  ║
  ║         /   \                                                ║
  ║       -3    -8                                               ║
  ║                                                              ║
  ║  Best path = just node -3 (single node with least loss)     ║
  ║                                                              ║
  ║  WRONG if global_max initialized to 0:                       ║
  ║    → Would return 0, but 0 isn't a valid path sum            ║
  ║    → Path must contain at least one node                     ║
  ║                                                              ║
  ║  RIGHT: global_max initialized to -infinity                  ║
  ║    → path_through at node -3 = -3 + 0 + 0 = -3              ║
  ║    → path_through at node -5 = -5 + 0 + 0 = -5              ║
  ║    → path_through at node -8 = -8 + 0 + 0 = -8              ║
  ║    → max(-3, -5, -8) = -3  ✓                                ║
  ║                                                              ║
  ║  KEY: max(0, child_gain) handles "don't extend into         ║
  ║  negative subtrees" but the NODE ITSELF is always included  ║
  ║  in path_through. So single-node paths are always           ║
  ║  considered as candidates.                                   ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 4: Python recursion limit                           ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  Python default recursion limit: ~1000                       ║
  ║  Skewed tree with N = 100,000 → stack overflow!              ║
  ║                                                              ║
  ║  FIX Option 1: sys.setrecursionlimit(200001)                ║
  ║    → Quick fix but risky (actual stack overflow possible)    ║
  ║                                                              ║
  ║  FIX Option 2: Iterative DFS (Version 3 above)              ║
  ║    → BFS to get parent array                                 ║
  ║    → Reverse BFS order = post-order                          ║
  ║    → Process in post-order with arrays                       ║
  ║    → Safe for any tree size                                  ║
  ║                                                              ║
  ║  FIX Option 3: threading with larger stack                   ║
  ║    import threading                                          ║
  ║    threading.stack_size(10**8)                                ║
  ║    thread = threading.Thread(target=solve)                   ║
  ║    thread.start()                                            ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  PITFALL 5: Confusing "root of DFS" with "start of path"    ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  We root the tree at node 0 for DFS traversal.               ║
  ║  But the OPTIMAL PATH can start and end ANYWHERE.            ║
  ║                                                              ║
  ║  The choice of root doesn't affect the answer because:       ║
  ║    → We consider every node as a potential turning point     ║
  ║    → global_max captures the best path across all nodes      ║
  ║    → Rooting just defines parent/child for the DFS,          ║
  ║      not the actual path endpoints                           ║
  ║                                                              ║
  ║  You can root at ANY node and get the same answer.           ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Single node tree                                 ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  N = 1, values = [42]                                        ║
  ║  → No children, path_through = 42                            ║
  ║  → Answer = 42  ✓                                            ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Star graph (one center, many leaves)             ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║        0(center)                                             ║
  ║      / | | | \                                               ║
  ║     1  2 3 4  5                                              ║
  ║                                                              ║
  ║  Center has many children but path can use at most 2.        ║
  ║  We pick TOP-2 positive child gains → correct.               ║
  ║                                                              ║
  ║  Using sorted() would be O(k log k) per node.               ║
  ║  Using top-2 tracking is O(k) per node.                      ║
  ║  For star graph: k = N-1, so this matters!                   ║
  ╚══════════════════════════════════════════════════════════════╝

  ╔══════════════════════════════════════════════════════════════╗
  ║  EDGE CASE: Long chain (linked list tree)                    ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                              ║
  ║  0 — 1 — 2 — 3 — 4 — 5                                     ║
  ║                                                              ║
  ║  Every node has at most 1 child (except root: 0 or 1 child) ║
  ║  → best1 exists, best2 = 0 always                           ║
  ║  → path_through = node_val + best1 + 0                      ║
  ║  → Effectively finds best contiguous subarray on a line      ║
  ║  → Similar to Kadane's algorithm!                            ║
  ╚══════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 14: THE DEEP INTUITION — Why "Return ≠ Record" Works</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  THE FUNDAMENTAL INSIGHT OF TREE PATH DP
  ═══════════════════════════════════════════════════════════════
  
  Every simple path in a tree looks like this:
  
    endpoint_A  →  ...  →  turning_point  →  ...  →  endpoint_B
                          (highest node)
                          
  The path goes UP from A to the turning point,
  then DOWN from the turning point to B.
  
  (A and B can be the same node → single-node path)
  (A or B can be the turning point → chain, not bent)
  
  OUR STRATEGY:
  
  For EACH node, assume it's the turning point.
  Compute the best path with THIS node as turning point.
  The answer is the maximum across ALL nodes.
  
  WHY THIS IS CORRECT:
  → Every path has exactly ONE turning point
  → We check every node as turning point
  → So we check every possible path
  → Taking the max gives the global optimum
  
  ═══════════════════════════════════════════════════════════════
  WHY "RETURN" IS A CHAIN (not a bent path)
  ═══════════════════════════════════════════════════════════════
  
  When node X returns max_gain to its parent P:
  
  P needs to know: "What's the best chain coming UP from X?"
  
  A chain is a STRAIGHT LINE: 
    some_leaf → ... → X → P
    
  P will then either:
    a) Continue the chain further up to P's parent, OR
    b) Use X's chain + another child's chain to form a BENT path at P
    
  If X returned a BENT path (using two children):
    P couldn't extend it — the path already uses both 
    "slots" at X (in from child1, out to child2).
    Adding P would create a fork, not a path.
    
  So X returns its best CHAIN, and X's bent path goes to global_max.
  
  ═══════════════════════════════════════════════════════════════
  ANALOGY: River System
  ═══════════════════════════════════════════════════════════════
  
  Think of the tree as a river system (tributaries flowing to ocean).
  
  At each junction (node):
    → Multiple tributaries flow IN from children
    → Only ONE stream flows OUT to parent
    → But the LONGEST water route might go 
      from one tributary THROUGH the junction to another tributary
      
  Return to parent: longest single tributary (one direction)
  Record globally: longest route through this junction (two directions)
  
                  to parent (RETURN)
                     ↑
                     |
  child1 stream →  junction  ← child2 stream
                  (RECORD: child1→junction→child2 length)</code></pre></div>
<hr>
<h2>STEP 15: COMPLETE MENTAL MODEL FOR TREE DP</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  TREE DP THINKING FRAMEWORK (applies to ALL tree DP problems)
  ═══════════════════════════════════════════════════════════════
  
  Step 1: IDENTIFY WHAT YOU'RE OPTIMIZING
    → Max path sum? Tree diameter? Min vertex cover?
    → Independent set? Coloring? Matching?
    
  Step 2: DEFINE THE STATE
    → "What does each node need to compute?"
    → "What does each node need to REPORT to its parent?"
    → "What does each node RECORD for the global answer?"
    
  Step 3: DEFINE THE TRANSITION
    → "Given all children's reports, how do I compute MY state?"
    → Usually: combine children's values with node's own value
    
  Step 4: DETERMINE WHAT TO RETURN vs RECORD
    → Return: what parent can USE to extend its computation
    → Record: what contributes to the GLOBAL answer but 
              can't be extended further
    → These are often DIFFERENT (the key insight!)
    
  Step 5: IMPLEMENT AS DFS POST-ORDER
    → Process children first (recursion)
    → Combine results
    → Update global answer
    → Return value to parent
    
  Step 6: HANDLE EDGE CASES
    → All negative values
    → Single node
    → Skewed tree (recursion depth)
    → Empty tree

  ═══════════════════════════════════════════════════════════════
  DECISION: "Is this a tree DP problem?"
  ═══════════════════════════════════════════════════════════════
  
  YES if:
    ✓ The input is a tree (or can be converted to one)
    ✓ The answer depends on subtree properties
    ✓ You can decompose: "answer for this subtree = 
       f(this node, answers for child subtrees)"
    ✓ Each subtree's answer is independent of other subtrees
      (except through the parent)
      
  EXAMPLES of tree DP problems:
    → Max/min path sum (this problem)
    → Tree diameter (variation above)
    → House Robber III (max independent set)
    → Binary tree cameras (min vertex cover variant)
    → Distribute coins in binary tree
    → Sum of distances in tree (rerooting DP)
    → Count good nodes
    → Longest zigzag path</code></pre></div>
<hr>
<h2>STEP 16: ADVANCED EXTENSION — REROOTING TECHNIQUE</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ═══════════════════════════════════════════════════════════════
</span>  PROBLEM: Sum of Distances in Tree (LeetCode 834)
  ═══════════════════════════════════════════════════════════════
  
  Given a tree with N nodes, for EACH node, compute the sum 
  of distances to ALL other nodes.
  
  Naive: Run BFS from each node → O(N²)
  Smart: Rerooting DP → O(N)
  
  IDEA:
    Phase 1: Root at node 0. Compute:
      → subtree_size[node]: number of nodes in subtree
      → dist_sum[0]: sum of distances from root 0 to all nodes
      
    Phase 2: "Reroot" — compute answer for every other node
      When we move the root from parent P to child C:
      → Nodes in C's subtree get 1 CLOSER (they're now below the root)
      → Nodes NOT in C's subtree get 1 FARTHER (they're now above)
      
      answer[C] = answer[P] 
                  - subtree_size[C]     (C's subtree: each 1 closer)
                  + (N - subtree_size[C]) (rest: each 1 farther)
                  
      = answer[P] - 2 * subtree_size[C] + N
      
  This is "rerooting" — a SECOND DFS that propagates from root to leaves.</code></pre></div>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span class="token" style="color: rgb(0, 0, 255);">def</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">sum_of_distances</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>    </span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">"""
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    LeetCode 834: Sum of Distances in Tree
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    For each node, compute sum of distances to all other nodes.
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Two-phase tree DP:
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Phase 1 (bottom-up): compute subtree sizes and root's answer
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">      Phase 2 (top-down):  reroot to compute every node's answer
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Time:  O(N) — two DFS passes
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    Space: O(N)
</span><span class="token triple-quoted-string" style="color: rgb(163, 21, 21);">    """</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">from</span><span> collections </span><span class="token" style="color: rgb(0, 0, 255);">import</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> deque
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> n </span><span class="token" style="color: rgb(57, 58, 52);">==</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    adj </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> defaultdict</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token builtin">list</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> u</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> v </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>v</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>u</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    parent </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">-</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    order </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># BFS order</span><span>
</span><span>    subtree_size </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    dist_sum </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── BFS to get parent and order ───</span><span>
</span><span>    visited </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">False</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    queue </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> deque</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>    visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">while</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        node </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>popleft</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        order</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> </span><span class="token" style="color: rgb(0, 0, 255);">not</span><span> visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>                visited</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">True</span><span>
</span><span>                parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> node
</span><span>                queue</span><span class="token" style="color: rgb(57, 58, 52);">.</span><span>append</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Phase 1: Bottom-up (reverse BFS order) ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Compute subtree_size and dist_sum for root</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> </span><span class="token builtin">reversed</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>order</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># nei is child</span><span>
</span><span>                subtree_size</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> subtree_size</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                dist_sum</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+=</span><span> dist_sum</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> subtree_size</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Why + subtree_size[nei]?</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Each node in nei's subtree is 1 edge further from node</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># than from nei. So add 1 per node = subtree_size[nei].</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Now dist_sum[0] = sum of distances from root 0 to all nodes</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># ─── Phase 2: Top-down reroot (BFS order) ───</span><span>
</span><span>    </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># answer[0] = dist_sum[0] (already computed)</span><span>
</span><span>    answer </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">*</span><span> n
</span><span>    answer</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> dist_sum</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> node </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> order</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>        </span><span class="token" style="color: rgb(0, 0, 255);">for</span><span> nei </span><span class="token" style="color: rgb(0, 0, 255);">in</span><span> adj</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>
</span><span>            </span><span class="token" style="color: rgb(0, 0, 255);">if</span><span> nei </span><span class="token" style="color: rgb(57, 58, 52);">!=</span><span> parent</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">:</span><span>  </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># nei is child</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Rerooting formula:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Moving root from node to nei:</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   nei's subtree (size = subtree_size[nei]): each 1 closer</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   rest (size = n - subtree_size[nei]): each 1 farther</span><span>
</span><span>                answer</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> answer</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>node</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> subtree_size</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">+</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n </span><span class="token" style="color: rgb(57, 58, 52);">-</span><span> subtree_size</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span>nei</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span>                </span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Simplified: answer[nei] = answer[node] + n - 2 * subtree_size[nei]</span><span>
</span>    
<span>    </span><span class="token" style="color: rgb(0, 0, 255);">return</span><span> answer
</span>

<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Test</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#     0</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#    / \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#   1   2</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;">#  / \</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># 3   4</span><span>
</span>
<span>n </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(54, 172, 170);">5</span><span>
</span><span>edges </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">0</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">2</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">3</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> </span><span class="token" style="color: rgb(57, 58, 52);">[</span><span class="token" style="color: rgb(54, 172, 170);">1</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span class="token" style="color: rgb(54, 172, 170);">4</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span class="token" style="color: rgb(57, 58, 52);">]</span><span>
</span><span>result </span><span class="token" style="color: rgb(57, 58, 52);">=</span><span> sum_of_distances</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span>n</span><span class="token" style="color: rgb(57, 58, 52);">,</span><span> edges</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span><span></span><span class="token" style="color: rgb(0, 0, 255);">print</span><span class="token" style="color: rgb(57, 58, 52);">(</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">f"Sum of distances: </span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">{</span><span class="token string-interpolation interpolation">result</span><span class="token string-interpolation interpolation" style="color: rgb(57, 58, 52);">}</span><span class="token string-interpolation" style="color: rgb(163, 21, 21);">"</span><span class="token" style="color: rgb(57, 58, 52);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Verification:</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># dist from 0: to 1=1, to 2=1, to 3=2, to 4=2 → sum = 6</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># dist from 1: to 0=1, to 2=2, to 3=1, to 4=1 → sum = 5</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># dist from 2: to 0=1, to 1=2, to 3=3, to 4=3 → sum = 9</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># dist from 3: to 0=2, to 1=1, to 2=3, to 4=2 → sum = 8</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># dist from 4: to 0=2, to 1=1, to 2=3, to 3=2 → sum = 8</span><span>
</span><span></span><span class="token" style="color: rgb(0, 128, 0); font-style: italic;"># Expected: [6, 5, 9, 8, 8]</span></code></pre></div>
<h3>Why Rerooting is Powerful</h3>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────┐
</span>  │  WITHOUT rerooting: O(N²)                                      │
  │    → Run BFS from each of N nodes                              │
  │    → Each BFS is O(N)                                          │
  │    → Total: O(N²)                                              │
  │                                                                │
  │  WITH rerooting: O(N)                                          │
  │    → Phase 1: one bottom-up pass O(N)                          │
  │    → Phase 2: one top-down pass O(N)                           │
  │    → Total: O(N)                                               │
  │                                                                │
  │  KEY INSIGHT:                                                   │
  │    When moving root from parent to child,                      │
  │    the answer changes by a PREDICTABLE FORMULA                 │
  │    based on subtree sizes.                                     │
  │                                                                │
  │    We don't recompute from scratch — we TRANSFORM.             │
  └────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 17: HOW I WOULD RECOGNIZE THIS PATTERN IN AN INTERVIEW</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ┌────────────────────────────────────────────────────────────────────┐
</span>  │                                                                    │
  │  "I see a TREE and need to find optimal PATH/SUBTREE property"    │
  │       → Tree DP                                                    │
  │                                                                    │
  │  "I see NODES with VALUES and need MAX/MIN PATH"                  │
  │       → This exact problem (max path sum)                         │
  │       → DFS returning chain, recording bent path                  │
  │                                                                    │
  │  "I need to compute something for EVERY NODE as root"             │
  │       → Rerooting technique (two-phase tree DP)                   │
  │                                                                    │
  │  "I can't rob adjacent nodes" or "can't pick adjacent"           │
  │       → Max independent set tree DP                               │
  │       → Two states: (pick_me, skip_me)                            │
  │                                                                    │
  │  "Find DIAMETER of tree"                                          │
  │       → Special case of max path sum with all values = 0         │
  │       → Or use two-BFS trick                                      │
  │                                                                    │
  │  RECOGNITION SIGNALS:                                              │
  │    → Tree structure (N nodes, N-1 edges)                          │
  │    → Optimization over paths or subtrees                          │
  │    → Answer decomposes into "this node + children's answers"      │
  │    → Words: "maximum", "minimum", "path", "subtree"              │
  │                                                                    │
  │  THINKING CHAIN:                                                   │
  │    "Tree + optimization"                                          │
  │    → "Can I decompose into subtree problems?"                     │
  │    → YES → "Tree DP with DFS post-order"                         │
  │    → "What do I return vs record?"                                │
  │    → "Return = what parent needs, Record = global candidate"      │
  │                                                                    │
  └────────────────────────────────────────────────────────────────────┘</code></pre></div>
<hr>
<h2>STEP 18: COMPLETE SUMMARY — Tree DP Master Reference</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔═══════════════════════════════════════════════════════════════════╗
</span>  ║  TREE DP MASTER TEMPLATE                                         ║
  ╠═══════════════════════════════════════════════════════════════════╣
  ║                                                                   ║
  ║  def solve_tree_dp(n, edges, values):                            ║
  ║      build adjacency list                                        ║
  ║      global_answer = initial_value                               ║
  ║                                                                   ║
  ║      def dfs(node, parent):                                      ║
  ║          # 1. Get results from all children                      ║
  ║          child_results = []                                      ║
  ║          for child in adj[node] if child != parent:              ║
  ║              child_results.append(dfs(child, node))              ║
  ║                                                                   ║
  ║          # 2. Compute RETURN value (for parent)                  ║
  ║          return_val = f(node_value, child_results)               ║
  ║                                                                   ║
  ║          # 3. Compute RECORD value (for global answer)           ║
  ║          record_val = g(node_value, child_results)               ║
  ║          global_answer = max(global_answer, record_val)          ║
  ║                                                                   ║
  ║          # 4. Return to parent                                   ║
  ║          return return_val                                       ║
  ║                                                                   ║
  ║      dfs(0, -1)                                                  ║
  ║      return global_answer                                        ║
  ║                                                                   ║
  ╠═══════════════════════════════════════════════════════════════════╣
  ║                                                                   ║
  ║  PROBLEM-SPECIFIC INSTANTIATIONS:                                ║
  ║                                                                   ║
  ║  Max Path Sum:                                                    ║
  ║    return_val = node_val + max(0, best_child_gain)               ║
  ║    record_val = node_val + top2_positive_child_gains             ║
  ║                                                                   ║
  ║  Tree Diameter:                                                   ║
  ║    return_val = 1 + max_child_depth                              ║
  ║    record_val = top2_child_depths_sum                            ║
  ║                                                                   ║
  ║  House Robber:                                                    ║
  ║    return_val = (rob_me, dont_rob_me) tuple                      ║
  ║    record_val = max(rob_me, dont_rob_me) at root                 ║
  ║                                                                   ║
  ║  Subtree Size:                                                    ║
  ║    return_val = 1 + sum(child_sizes)                             ║
  ║    record_val = not needed (or stored per node)                  ║
  ║                                                                   ║
  ╚═══════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>STEP 19: KEY TAKEAWAY</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  ╔════════════════════════════════════════════════════════════════════╗
</span>  ║                                                                    ║
  ║   NEW CONCEPT LEARNED: DYNAMIC PROGRAMMING ON TREES               ║
  ║                                                                    ║
  ║   1. CORE IDEA:                                                    ║
  ║      DFS post-order + combine children's answers                  ║
  ║      Trees have NATURAL recursive substructure                    ║
  ║                                                                    ║
  ║   2. THE CRITICAL DISTINCTION:                                     ║
  ║      RETURN to parent ≠ RECORD globally                           ║
  ║      → Return: extendable value (chain, single-direction)        ║
  ║      → Record: complete candidate (bent path, both directions)   ║
  ║                                                                    ║
  ║   3. THE max(0, ...) TRICK:                                       ║
  ║      Negative contributions → don't extend                       ║
  ║      "Path can start/end anywhere" = "cut off negative parts"    ║
  ║                                                                    ║
  ║   4. TIME COMPLEXITY: O(N)                                        ║
  ║      Visit each node once                                        ║
  ║      Process children in O(degree) per node                      ║
  ║      Total = O(sum of degrees) = O(N)                            ║
  ║                                                                    ║
  ║   5. TREE DP IS A SPECIAL CASE OF DAG DP:                        ║
  ║      A rooted tree IS a DAG (edges point parent → child)         ║
  ║      Post-order DFS = topological order for trees                ║
  ║      Problem 47 generalizes this to arbitrary DAGs               ║
  ║                                                                    ║
  ║   6. EXTENSIONS:                                                   ║
  ║      → Rerooting (compute answer for every node as root)         ║
  ║      → Multiple states (rob/don't rob)                           ║
  ║      → Path with constraints (min length, target sum)            ║
  ║      → Combine with LCA (Problem 45) for path queries            ║
  ║                                                                    ║
  ╚════════════════════════════════════════════════════════════════════╝</code></pre></div>
<hr>
<h2>CONNECTION TO NEXT PROBLEM</h2>
<div class="relative"><pre style="color: rgb(57, 58, 52); font-family: Consolas, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, Courier, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; font-size: 0.9em; line-height: 1.2em; tab-size: 4; hyphens: none; padding: 1em; margin: 0.5em 0px; overflow: auto; border: 1px solid rgb(221, 221, 221); background-color: white;"><code style="white-space: pre-wrap; word-break: break-all;"><span>  Problem 46: Tree DP
</span>    → DFS post-order on TREE, combine children's results
    → Tree is a special DAG → natural recursive structure
    → Post-order = "process children before parent"
    
  Problem 47: Graph DP (Longest Path in DAG)
    → TOPOLOGICAL SORT on general DAG, then DP relaxation
    → Generalizes tree DP to arbitrary DAGs
    → Topo sort replaces DFS post-order
    → "Process all predecessors before current node"
    
  The bridge:
    Tree DP:  post-order DFS → process children → combine at parent
    DAG DP:   topological sort → process predecessors → combine at node
    
    Same idea, different structure!
    Trees have ONE parent per node → DFS suffices
    DAGs have MULTIPLE predecessors per node → need topo sort</code></pre></div>
<hr>
</div>
</div>

<!-- ========== data-index="13" ========== -->

        </div>

        <div class="nav-bar">
            <a href="problem-45.html" class="nav-button prev">← Previous Problem</a>
            <div class="page-info">
                <a href="index.html" class="nav-button home">📚 Table of Contents</a><br>
                <span style="margin-top:8px;display:block">Problem 46 of 50</span>
            </div>
            <a href="problem-47.html" class="nav-button next">Next Problem →</a>
        </div>
    </div>

    
    <div id="progress-track"><div id="progress-fill"></div></div>
    <div id="progress-pct">0%</div>


    <script>
    const fill = document.getElementById('progress-fill');
    const pct  = document.getElementById('progress-pct');
    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrolled  = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
        fill.style.height = scrolled + '%';
        pct.textContent   = Math.round(scrolled) + '%';
    }
    window.addEventListener('scroll', updateProgress);
    updateProgress();

    document.addEventListener('keydown', function(e) {
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
        if (e.key === 'ArrowLeft') {
            const b = document.querySelector('.nav-button.prev');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
        if (e.key === 'ArrowRight') {
            const b = document.querySelector('.nav-button.next');
            if (b && !b.classList.contains('disabled')) window.location.href = b.href;
        }
    });
    </script>

</body>
</html>